[{"title":"Blender动画教程 - 熊猫跳舞 - 课程笔记","date":"2024-06-15T16:08:08.000Z","url":"/Blender/2024-06-16-blender/test.html","tags":[["ARP","/tags/ARP/"],["AutoRigPro","/tags/AutoRigPro/"],["角色绑定","/tags/%E8%A7%92%E8%89%B2%E7%BB%91%E5%AE%9A/"],["AI动作捕捉","/tags/AI%E5%8A%A8%E4%BD%9C%E6%8D%95%E6%8D%89/"]],"categories":[["Blender","/categories/Blender/"]],"content":"1 绑定前预检查 缩放旋转检查：Ctrl+A应用全部变化 模型对称检查&amp;朝向检查：X轴对称，脚站在红线上，脸朝向-y 曲线检查 大小检查：最好符合实际高度 模型面数检查：面数不能太多也太少。不足可以进入编辑模式Ctrl+R添加 父子级检查 修改器检查 绑定前应用：镜像修改器、实体化修改器、布尔修改器；（会参与变形的修改器） 可保留：细分表面修改器、阵列修改器、倒角修改器 备份检查：在修改器应用前也最好备份一下 2 ARP绑定 选中绑定的主体 打开ARP菜单：智能绑定 - 全身 确定 在智能绑定中添加各个节点；不需要手指可以选择取消；添加之后go会自动添加骨骼 调整骨骼 - ok之后在第一个菜单选择与绑定匹配；自动切换为姿态模式 - 右侧小窗口 物体属性 - 视图显示 勾选显示在前面 将模型绑定在控制器：切换为物体模式 - 选中模型 再选择控制器 - ARP菜单 切换蒙皮 - 绑定菜单 绑定 3.3 FBX的导入和重映射 导入 - FBX文件 勾选 骨架 - 自动骨骼坐标系 FBX会影响帧率；输出设置中可更改帧输出 ARP菜单 重映射 - 源骨架 点击骨骼 再点击菜单的吸管 - 目标骨架 点击控制器 再点击吸管 - 自动缩放 - 构建骨骼列表； 选择hips骨骼 设置为根（告诉插件熊猫的屁股根骨骼是该骨骼） - 重新定义静止姿态 - 当前姿态 - 应用 - 重新定义 - 确定 - 重新定位 3.4 FBX文件获取（使用方式）AI动作捕捉工具  动作生成工具 动作库  3.5 动画基础自动插帧 动画插口左侧的小圆点，是一个实时打关键帧的功能；激活之后自动记录所有变化。动画摄影表（动画标签中打开，一般与非线性动画搭配使用） 切换为动作编辑器模式，该模型下才能编辑和改名；下推 会移动到非线性动画编辑器里非线性动画 被下推的动作会显示为小黄块；选择小黄块按TAB推回动画摄影表 右侧标签 - 外插：保持 保持最帧的状态；保持前进 最后一帧保持 右侧标签 - 混合：替换和合并；可以设置多个动画之间的搭配 3.6 动作捕捉的修补与清理 检查项目设置 将骨骼从FK模式转换为IK模式 ARP菜单 - 姿态模式 - 选择手上的小方块 - ARP 绑定主要特性 设置 - 右侧小齿轮 - 烘焙FK&gt;IK - 设定帧数 确定； 四肢都要设定FK&gt;IK（都是为了方便后续做动作的清理） 修补 展开动画摄影表 - 动作编辑器，非线性动画；下推 后就可以开始K动作快捷键K 抖动太厉害可以切换到曲线编辑器：选中两只脚 A全选所有帧数 - 关键帧 平滑 高斯平滑 - 拉一下 20%就可以了 调整ok就下推 烘焙调整好的动作 非线性编辑器 - 片段 烘焙动作 - 取消 仅选中的骨骼 它会把所有合并到一个到动作编辑器 可以将其他的动作流删掉了，需要保存可以TAB上推回动作编辑器，改名后添加小盾牌 动作捕捉文件是FK运动模式（大臂带动小臂 正向运动学），需要改为IK模式（反向移动学）。 "},{"title":"农夫与蛇","date":"2023-11-25T21:02:00.000Z","url":"/%E6%97%A5%E8%AE%B0/2023-11-26-diary/%E5%86%9C%E5%A4%AB%E4%B8%8E%E8%9B%87.html","tags":[["认知","/tags/%E8%AE%A4%E7%9F%A5/"],["受害者","/tags/%E5%8F%97%E5%AE%B3%E8%80%85/"]],"categories":[["日记","/categories/%E6%97%A5%E8%AE%B0/"]],"content":"还在幼年时，第一次听农夫与蛇的故事，我的内心就有种特别的悸动。近日碰巧，他人和自己身边都发生了类似的案例。 那是一种很复杂的情绪，掺杂着愤怒、疑惑、不解，甚至带着点痛苦的酸味。 农夫临死前或许仍然也想不明白，“我不是帮了你了吗”。我也想得不太明白，假设简单地给蛇打上危险与邪恶的标签，那么在人类社会中都长得一个模样的众多人类中，为什么也会存在如动物般的冷血和恶劣呢？ 在我的亲身接触中，它们在自我认同上认知自己具有良好的品格。善良、道德、温柔，它们如此自述自我，可每每到具体的事件之中，高洁光亮的自我又竟淡然无存。有种用了更高级不同于普通大众世界观的美感。我猜想着，愚蠢或许是那个关键的因素。蠢到连对正常客观世界的认知都存在着扭曲，蠢在连一条清晰的逻辑链都画不出来。可它们又很聪明，它们总能赢，它们总能得到一个答案，一个自以为正确的答案。 但蠢这个因素非常难说，哪怕就逻辑回路来说，任何人都会存在某种正确，也会存在某种错误。而我在那么说着，也有那么几许可能，我就是那个蠢的人QAQ。所以需要再加个额外的因素，来判断什么是“正确”。此典故较多发生在人际关系中，那么人际关系中的双方或大家的利益，是一个个实实在在的好处，哪怕我们都是笨蛋，只要得到好处开心了，也不会在乎我们之间的谁对谁错。 所以愚蠢的表现为狭隘认知下只顾短期自我利益，损害他人利益并断送信誉的行为。实际上对于正常思维的人非常难以去想象甚至去回溯它们愚蠢的思维逻辑链到底是如何接通的，所以当我想书写点分析又不知不觉流露到单纯的情绪发泄上。 认知局限造成的愚蠢，非常经典的一个思维便是：受害者思维。只要心态够差，世界上就没有顺境。“受害者”其实是一种“儿童自我状态”，简单说就是巨婴，不具备主观能动性，不相信自己可以具备改变时局的能力。它们将一切降临在它们身上的事件，都认为是某种恶意或攻击。它们往往在成长过程中经常有被侵入的体验，身心边界不被尊重，很有可能并未拥有过自己能做决定的主观能动性。大概率，它们的养育者也同样是把问题归咎于外界的受害者。受害者们因事件引发的负面情绪，只会吸引来相同具有负面情绪的人，而相同的人又会强化受害者们的认知。它们制造了一个负面怪圈并深陷其中，慢慢这个环境变成一个生态圈，而它们自己就是其中的一部分。它的认知，对得起它的苦难。 受害者不解决问题，准确来说，是不重视自己的感受，等别人重视。将重视感受这个责任交给别人，别人没做好，自己便是受害者了。当把过错归咎在外界时，攻击时就不会有任何内疚感，因为内心没有冲突，它们是在理所当然地施虐。受害者的心理游戏是一种自我预言，它们掌控失败，它们永远失败，逃避责任和攻击外界是它们的最爱，那么做的最大好处就是可以不用去看见自己的需求。也许对于它们来说，比起感受需求从未被满足的匮乏感，还是永远失败更好受一些。 匮乏在每个人身上都有可能会发生，也许是因为客观因素，也许是因为特殊时期。匮乏状态下任何人都非常有可能做出自己本来也不希望的行为，这不是个人主观选择可以决定的。不论你天赋有多强、有多努力，也不管你心态有多好、有多么自律，一旦陷入金钱、认知和价值观的短缺，那必然会导致心力的匮乏，而人生也在面临枯萎。要对匮乏中的人抱有理解和谨慎，那是不得不如此，不必远离，但要有心理准备。 在此也发现偏执型人格也似乎与受害者思维有诸多相似；也察觉到大抵同样习得性无助存在受害者身上。这几乎是非常经典的巨婴特质，是成长中的缺失。 嗯其实实际上我真正想要解决的是如何让自己避免再度遇到这样的情况。因为过满的助人性，总爱多管闲事，时常也有那么一些不太值得帮助的人。这或许是我的过失，我虽然也从低谷里爬出，但我却总自以为积极成长的人生应该是人人都想要的。或许它们只是想要在底下在恢复点能量，是时机不对，但这都无关要紧。要在保护好自己的情况下，再考虑救援的事情。要认清人类存在着多样性这一特点，有部分人群就只是单单实现这个功能的NPC。碰见它们只是概率问题，无论你存在与否，它们会平等地恶心遇见它们的每一个人。 抛开那些乱七八糟的问题，再从另外一个方面看，这也说明我说服力的低下。常常会考虑他人的感受，便会相当曲折地去指出缺点，甚至是思考到了底层逻辑。等到说出口的时候，软绵绵又让人听不懂。能听得懂的人不用说服，需要说服的人又听不进去。这恰恰是表明说服技能还不够。实际上没有人能被真正的说服，说服本质上是提醒对方本来就知道只不过暂时忘记了的事情，所以常常来说，我只能说服同等认知的人。而对于认知于我之下，我只能看出对方的低下，却无法考虑到并切换到对方的水平。"},{"title":"线程基础","date":"2022-06-30T13:02:00.000Z","url":"/%E7%AE%97%E6%B3%95/2022-06-30-program/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html","categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":"01 线程简介程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。 进程则是执行程序的一次执行过程，它是一个动态的概念。 是系统资源分配的单通常在一个进程中可以包含若干个线程，当然一个进程中至少有一 个线程，不然没有存在的意义。 线程是CPU调度和执行的的单位。 注意：很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务器。如果是模拟出来的多线程，即在一个cpu的情况下， 在同一个时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错局。 ![[Pasted image 20220617171043.png]] 1.1 核心概念 线程就是独立的执行路径; 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程, gc线程; main()称之为主线程，为系统的入口，用于执行整个程序; 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度,调度器是与操作系统紧密相关的，先后顺序是不能认为的干预的。 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制; 线程会带来额外的开销,如cpu调度时间，并发控制开销。 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致 02 线程创建2.1 继承Thread子类继承Thread类具备多线程能力 启动线程：子类对象.start() 不建议使用：避免OOP单继承局限性 2.2 实现Runnable接口实现接口Runnable具有多线程能力 启动线程：传入目标对象 + Thread对象.start() 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 2.3实现Callable接口 实现Callable接口，需要返回值类型 重写call方法，需要抛出异常 创建目标对象 创建执行服务： 提交执行： 获取结果 关闭服务 03 线程状态![[Pasted image 20220620145615.png]]![[Pasted image 20220620145643.png]] setPriority(int newPriority)，更改线程优先级。static void sleep(long millis)，在指定的毫秒数内让当前正在执行的线程休眠。void join()，等待该线程终止。static void yield()，暂停当前正在执行的线程对象，并执行其他线程。void interrupt()，中断线程，别用这个方式。boolean isAlive()，测试线程是否处于活动状态。 3.1 线程停止不建议使用JDK提供的stop()、destroy()方法。【已废弃】推荐线程自己停止下来建议使用一个标志位进行终止变量但flag&#x3D;false，则终止线程运行。 3.2 线程休眠 sleep(时间) 指定当前线程阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延时，倒计时等 每一个对象都有一个锁，sleep不会释放锁 3.3 线程礼让 礼让线程，让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让CPU重新调度，礼让不一定成功，看CPU心情 3.4 线程强制执行 Join合并线程，待此线程完成后，再执行其他线程，其他线程阻塞 可以想象成插队 3.5 线程状态观测Thread.State 线程状态，线程可以处于以下状态之一： NEW，尚未启动的线程处于此状态。 RUNNABLE，在Java虚拟机中执行的线程处于此状态。 BLOCKED，被阻塞等待监视器锁定的线程处于此状态。 WAITING，正在等待另一个线程执行特定动作的线程处于此状态。 TIMED_WAITING，正在等待另一个线程执行动作达到指定等待时间的线程处于此状态 TERMINATED，已退出的线程处于此状态。 3.6 线程优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。 线程的优先级用数字表示，范围从1~10 Thread.MIN_PRIORITY &#x3D; 1; Thread.MAX_PRIORITY &#x3D; 10; Thread.NORM_PRIORITY &#x3D; 5; 使用以下方式改变或获取优先级 getPriority() setPriority(int xxx) 优先级的设定建议在start()调度前 优先级低只是意味着获得调度的概率地，并不是优先级低就不会被调用，这都是看CPU的调度。 3. 7 守护线程 daemon 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕 如：后台记录操作日志、监控内存、垃圾回收等待 04 线程同步4.1 并发并发：同一个对象被多个线程同时操作 例如：上万人同时抢票；一个账户两个银行地点同时取钱 处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用。（排队） 由于同一进程的多个线程共享同一快存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制 synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起； 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题； 如果一个优先级高的线程等待一个优先级低的线程释放锁 会导致优先级倒置，引起性能问题。 4.2 同步方法由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized方法和synchronized块。 synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后门被阻塞的线程才能获得这个锁，继续执行。缺陷：若将一个大的方法声明为synchronized将会影响效率。 方法里面需要修改的内容才需要锁，锁得太多，浪费资源。 4.3 同步块同步块：synchronized(Obj) {} obj 称之为 同步监视器Obj 可以是任何对象，但是推荐使用共享资源作为同步监视器。同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者class 同步监视器的执行过程 第一个线程访问，锁定同步监视器，执行其中代码。 第二个线程访问，发现同步监视器被锁定，无法访问。 第一个线程访问完毕，解锁同步监视器。 第二个线程访问，发现同步监视器没有锁，然后锁定并访问。 05 锁5.1 死锁多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。 5.2 死锁避免方法产生死锁的四个必要条件： 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞，对已获得的资源保持不妨。 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。 循环等待条件，若干进程之间形成一种头尾相接的循环等待资源关系。 上面列出了死锁的四个必要条件，我们只要想办法破了其中的任意一个或多个条件就可以避免死锁发生。 5.3 Lock从JDK 5.0开始，Java提供了更强大的线程同步机制 —— 通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock, 可以显式加锁、释放锁。 5.4 synchronized 与 Lock 的对比 Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁， 出了作用域自动释放。 Lock只有代码块锁，synchronized有代码块锁和方法锁。 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类) 优先使用顺序：Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源） &gt; 同步方法（在方法体之外） 06 线程协作线程通信 - 生产者和消费者模式 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费。 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止。 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。 线程通信 - 分析这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。 对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费。 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费。 在生产者消费者问题中，仅有synchronized是不够的 synchronized 可阻止并发更新同一个共享资源，实现了同步 synchronized 不能用来实现不同线程之间的消息传递(通信) Java提供了几个方法解决线程之间的通信问题 wait()，表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁。 wait(long timeout)，指定等待的毫秒数 notify()，唤醒-个处于等待状态的线程 notifyAll()，唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException 解决方式1 - 管程法并发协作模型“生产者 &#x2F; 消费者模式”–&gt;管程法 生产者：负责生产数据的模块(可能是方法,对象,线程,进程); 消费者：负责处理数据的模块(可能是方法,对象,线程,进程); 缓冲区：消费者不能直接使用生产者的数据,他们之间有个缓冲区生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据 解决方式2 - 信号灯法并发协作模型“生产者 &#x2F; 消费者模式”–&gt;信号灯法 07 线程池 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程,放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 好处： 提高响应速度(减少了创建新线程的时间) 降低资源消耗(重复利用线程池中线程,不需要每次都创建) 便于线程管理(…) corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 JDK 5.0起提供了线程池相关API：ExecutorService和Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 "},{"title":"排序算法","date":"2022-06-17T15:36:31.000Z","url":"/%E7%AE%97%E6%B3%95/2022-06-17-program/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html","categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":"选择排序算法步骤 从头到位遍历一遍数组，找出最小的元素，放到最开始的位置。 下标++，将最开始的数排出排序，继续重复1直到所有元素排序完毕。 Java实现 冒泡排序算法步骤 比较相邻的两个数，大的向后移。 最后的数是当前组中最大的了。从头开始步骤1的循环，直至排序结束。 Java实现 插入排序算法步骤 将第一个元素看作有序序列，第二个至最后看作无序。 选择无序中第一个元素，一一与有序中元素比较，直到不符合条件就插入到当前对比的位置上。 有序+1，无序-1，循环。 Java实现 希尔排序希尔排序是改进的插入排序 算法步骤 选定一个间隔数，按照间隔数分组。 组内进行排序。 重新设置间隔数，重新再排序，循环。（间隔数至1时就是普通的插入排序） Java实现 "},{"title":"时间与空间复杂度","date":"2022-06-17T13:55:25.000Z","url":"/%E7%AE%97%E6%B3%95/2022-06-17-program/%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html","categories":[["算法","/categories/%E7%AE%97%E6%B3%95/"]],"content":"时间复杂度时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。 大O「 大O符号表示法 」，即 T(n) &#x3D; O(f(n))。 其中 n 表示数据规模 ，O(f(n))表示运行算法所需要执行的指令数，和f(n)成正比。 常见的时间复杂度量级 常数阶O(1) 线性阶O(n) 平方阶O(n²) 对数阶O(logn) 线性对数阶O(nlogn) ![[Pasted image 20220114174550.png]] 递归算法的时间复杂度如果递归函数中，只进行一次递归调用，递归深度为depth；在每个递归的函数中，时间复杂度为T；则总体的时间复杂度为O(T * depth)。 归并排序 与 快速排序 都带有递归的思想，并且时间复杂度都是O(nlogn) ，但并不是有递归的函数就一定是 O(nlogn) 级别的。从递归中进行一次递归调用的复杂度分析、递归中进行多次递归调用的复杂度分析。 具体举例分析 最好、最坏情况时间复杂度最好、最坏情况时间复杂度指的是特殊情况下的时间复杂度。 当数组中第一个元素就是要找的 x 时，时间复杂度是 O(1)；而当最后一个元素才是 x 时，时间复杂度则是 O(n)。 最好情况时间复杂度就是在最理想情况下执行代码的时间复杂度，它的时间是最短的；最坏情况时间复杂度就是在最糟糕情况下执行代码的时间复杂度，它的时间是最长的。 平均情况时间复杂度最好、最坏时间复杂度反应的是极端条件下的复杂度，发生的概率不大，不能代表平均水平。那么为了更好的表示平均情况下的算法复杂度，就需要引入平均时间复杂度。 平均情况时间复杂度可用代码在所有可能情况下执行次数的加权平均值表示。 还是以 find 函数为例，从概率的角度看， x 在数组中每一个位置的可能性是相同的，为 1 &#x2F; n。那么，那么平均情况时间复杂度就可以用下面的方式计算： ((1 + 2 + … + n) &#x2F; n + n) &#x2F; 2 &#x3D; (3n + 1) &#x2F; 4 find 函数的平均时间复杂度为 O(n)。 均摊复杂度分析一个相对比较耗时的操作，如果能保证它不会每次都被触发，那么这个相对比较耗时的操作，它所相应的时间是可以分摊到其它的操作中来的。 空间复杂度空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。 一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分： 固定部分，这部分空间的大小与输入&#x2F;输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。 一个算法所需的存储空间用f(n)表示。S(n)&#x3D;O(f(n))，其中n为问题的规模，S(n)表示空间复杂度。 空间复杂度可以理解为除了原始序列大小的内存，在算法过程中用到的额外的存储空间。 平衡二叉树如果二叉树的是以红黑树等平衡二叉树实现的，则 n 个节点的二叉排序树的高度为 log2n+1 ，其查找效率为O(Log2n)，近似于折半查找。 列表二叉树如果二叉树退变为列表了，则 n 个节点的高度或者说是长度变为了n，查找效率为O(n)，变成了顺序查找。 一般二叉树介于「列表二叉树」与「平衡二叉树」之间，查找性能也在O(Log2n)到O(n)之间。 时间与空间对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。 比如说，要判断某某年是不是闰年： 可以编写一个算法来计算，这也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。 还有另一个办法就是，事先建立一个有 5555 个元素的数组（年数比现实多就行），然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是1，如果不是值为0。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时，我们的运算是最小化了，但是硬盘上或者内存中需要存储这 5555 个 0 和 1 。这就是典型的使用空间换时间的概念。 当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。 另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。"},{"title":"Categories","date":"2024-06-15T15:34:24.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"Search","date":"2024-06-15T15:34:58.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"Tags","date":"2024-06-15T15:33:37.000Z","url":"/tags/index.html","categories":[[" ",""]]}]