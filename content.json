{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com"},"pages":[],"posts":[{"title":"线程基础","slug":"线程基础","date":"2022-06-30T05:02:00.000Z","updated":"2022-06-30T05:02:25.058Z","comments":true,"path":"2022/06/30/线程基础/","link":"","permalink":"http://example.com/2022/06/30/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/","excerpt":"","text":"01 线程简介程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。 进程则是执行程序的一次执行过程，它是一个动态的概念。 是系统资源分配的单通常在一个进程中可以包含若干个线程，当然一个进程中至少有一 个线程，不然没有存在的意义。 线程是CPU调度和执行的的单位。 注意：很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务器。如果是模拟出来的多线程，即在一个cpu的情况下， 在同一个时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错局。 ![[Pasted image 20220617171043.png]] 1.1 核心概念 线程就是独立的执行路径; 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程, gc线程; main()称之为主线程，为系统的入口，用于执行整个程序; 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度,调度器是与操作系统紧密相关的，先后顺序是不能认为的干预的。 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制; 线程会带来额外的开销,如cpu调度时间，并发控制开销。 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致 02 线程创建2.1 继承Thread子类继承Thread类具备多线程能力 启动线程：子类对象.start() 不建议使用：避免OOP单继承局限性 123456789101112131415161718192021222324// 创建线程方式一：继承Thread类，重写run()方法，调用start开启线程 // 线程开启不一定立即执行， 由CPU调度执行 public class ThreadTest1 extends Thread &#123; @Override public void run() &#123; // run方法线程体 for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;在看代码 --- &quot; + i); &#125; &#125; public static void main(String[] args) &#123; // main线程，主线程 // 创建一个线程对象 ThreadTest1 threadTest1 = new ThreadTest1(); // 调用start()方法开启线程 threadTest1.start(); for (int i = 0; i &lt; 2000; i++) &#123; System.out.println(&quot;学习 --- &quot; + i); &#125; &#125; &#125; 2.2 实现Runnable接口实现接口Runnable具有多线程能力 启动线程：传入目标对象 + Thread对象.start() 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 12345678910111213141516171819202122// 实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法 public class ThreadTest2 implements Runnable &#123; @Override public void run() &#123; // run方法线程体 for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;在看代码 --- &quot; + i); &#125; &#125; public static void main(String[] args) &#123; // 创建Runnable接口的实现类对象 ThreadTest2 threadTest2 = new ThreadTest2(); // 创建线程对象，通过线程对象来开启我们的线程，代理 new Thread(threadTest2).start(); for (int i = 0; i &lt; 2000; i++) &#123; System.out.println(&quot;学习 --- &quot; + i); &#125; &#125; &#125; 2.3实现Callable接口 实现Callable接口，需要返回值类型 重写call方法，需要抛出异常 创建目标对象 创建执行服务： 1ExecutorService ser = Executors.newFixedThreadPool(1); 提交执行： 1Future&lt;Boolean&gt; result1 = ser.submit(t1); 获取结果 1boolean r1 = result1.get(); 关闭服务 1ser.shutdownNow(); 03 线程状态![[Pasted image 20220620145615.png]]![[Pasted image 20220620145643.png]] setPriority(int newPriority)，更改线程优先级。static void sleep(long millis)，在指定的毫秒数内让当前正在执行的线程休眠。void join()，等待该线程终止。static void yield()，暂停当前正在执行的线程对象，并执行其他线程。void interrupt()，中断线程，别用这个方式。boolean isAlive()，测试线程是否处于活动状态。 3.1 线程停止不建议使用JDK提供的stop()、destroy()方法。【已废弃】推荐线程自己停止下来建议使用一个标志位进行终止变量但flag&#x3D;false，则终止线程运行。 123456789101112131415public class TestStop implements Runnable &#123; // 1. 线程中定义线程体使用的表示 private boolean flag = true; @Override public void run() &#123; // 2. 线程体使用该标识 while (flag) System.out.println(&quot;run... Thread&quot;); &#125; // 3. 对外提供方法改变标识 public void stop() &#123; this.flag = false; &#125;&#125; 3.2 线程休眠 sleep(时间) 指定当前线程阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延时，倒计时等 每一个对象都有一个锁，sleep不会释放锁 3.3 线程礼让 礼让线程，让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让CPU重新调度，礼让不一定成功，看CPU心情 3.4 线程强制执行 Join合并线程，待此线程完成后，再执行其他线程，其他线程阻塞 可以想象成插队 1234567891011121314151617181920public class ThreadTest6 implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;线程VIP来了&quot; + i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 启动我们的线程 ThreadTest6 join = new ThreadTest6(); Thread thread = new Thread(join);; thread.start(); // 主线程 for (int i = 0; i &lt; 1000; i++) &#123; if (i == 200) thread.join(); System.out.println(&quot;main&quot; + i); &#125; &#125; &#125; 3.5 线程状态观测Thread.State 线程状态，线程可以处于以下状态之一： NEW，尚未启动的线程处于此状态。 RUNNABLE，在Java虚拟机中执行的线程处于此状态。 BLOCKED，被阻塞等待监视器锁定的线程处于此状态。 WAITING，正在等待另一个线程执行特定动作的线程处于此状态。 TIMED_WAITING，正在等待另一个线程执行动作达到指定等待时间的线程处于此状态 TERMINATED，已退出的线程处于此状态。 3.6 线程优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。 线程的优先级用数字表示，范围从1~10 Thread.MIN_PRIORITY &#x3D; 1; Thread.MAX_PRIORITY &#x3D; 10; Thread.NORM_PRIORITY &#x3D; 5; 使用以下方式改变或获取优先级 getPriority() setPriority(int xxx) 优先级的设定建议在start()调度前 优先级低只是意味着获得调度的概率地，并不是优先级低就不会被调用，这都是看CPU的调度。 3. 7 守护线程 daemon 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕 如：后台记录操作日志、监控内存、垃圾回收等待 04 线程同步4.1 并发并发：同一个对象被多个线程同时操作 例如：上万人同时抢票；一个账户两个银行地点同时取钱 处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用。（排队） 由于同一进程的多个线程共享同一快存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制 synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起； 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题； 如果一个优先级高的线程等待一个优先级低的线程释放锁 会导致优先级倒置，引起性能问题。 4.2 同步方法由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized方法和synchronized块。 12// 同步方法public synchronized void method(int args) &#123;&#125; synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后门被阻塞的线程才能获得这个锁，继续执行。缺陷：若将一个大的方法声明为synchronized将会影响效率。 方法里面需要修改的内容才需要锁，锁得太多，浪费资源。 4.3 同步块同步块：synchronized(Obj) {} obj 称之为 同步监视器Obj 可以是任何对象，但是推荐使用共享资源作为同步监视器。同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者class 同步监视器的执行过程 第一个线程访问，锁定同步监视器，执行其中代码。 第二个线程访问，发现同步监视器被锁定，无法访问。 第一个线程访问完毕，解锁同步监视器。 第二个线程访问，发现同步监视器没有锁，然后锁定并访问。 05 锁5.1 死锁多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。 5.2 死锁避免方法产生死锁的四个必要条件： 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞，对已获得的资源保持不妨。 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。 循环等待条件，若干进程之间形成一种头尾相接的循环等待资源关系。 上面列出了死锁的四个必要条件，我们只要想办法破了其中的任意一个或多个条件就可以避免死锁发生。 5.3 Lock从JDK 5.0开始，Java提供了更强大的线程同步机制 —— 通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock, 可以显式加锁、释放锁。 1234567891011class A &#123; private final ReentrantLock lock = new ReenTrantLock(); public void m() &#123; lock.lock(); try&#123; // 保证线程安全的代码 &#125; finally &#123; lock.unlock; // 如果同步代码有异常，要将unlock写入finally语句块 &#125; &#125;&#125; 5.4 synchronized 与 Lock 的对比 Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁， 出了作用域自动释放。 Lock只有代码块锁，synchronized有代码块锁和方法锁。 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类) 优先使用顺序：Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源） &gt; 同步方法（在方法体之外） 06 线程协作线程通信 - 生产者和消费者模式 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费。 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止。 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。 线程通信 - 分析这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。 对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费。 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费。 在生产者消费者问题中，仅有synchronized是不够的 synchronized 可阻止并发更新同一个共享资源，实现了同步 synchronized 不能用来实现不同线程之间的消息传递(通信) Java提供了几个方法解决线程之间的通信问题 wait()，表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁。 wait(long timeout)，指定等待的毫秒数 notify()，唤醒-个处于等待状态的线程 notifyAll()，唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException 解决方式1 - 管程法并发协作模型“生产者 &#x2F; 消费者模式”–&gt;管程法 生产者：负责生产数据的模块(可能是方法,对象,线程,进程); 消费者：负责处理数据的模块(可能是方法,对象,线程,进程); 缓冲区：消费者不能直接使用生产者的数据,他们之间有个缓冲区生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据 解决方式2 - 信号灯法并发协作模型“生产者 &#x2F; 消费者模式”–&gt;信号灯法 07 线程池 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程,放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 好处： 提高响应速度(减少了创建新线程的时间) 降低资源消耗(重复利用线程池中线程,不需要每次都创建) 便于线程管理(…) corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 JDK 5.0起提供了线程池相关API：ExecutorService和Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor123void execute(Runnable command) // 执行任务/命令，没有返回值，一般用来执行Runnable&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) // 执行任务,有返回值, 一般又来执行Callablevoid shutdown() // 关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池","raw":null,"content":null,"categories":[],"tags":[]},{"title":"排序算法","slug":"排序算法","date":"2022-06-17T07:36:31.000Z","updated":"2022-06-17T07:37:21.671Z","comments":true,"path":"2022/06/17/排序算法/","link":"","permalink":"http://example.com/2022/06/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"选择排序算法步骤 从头到位遍历一遍数组，找出最小的元素，放到最开始的位置。 下标++，将最开始的数排出排序，继续重复1直到所有元素排序完毕。 Java实现123456789101112public static void selectionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex; System.out.println(arr[minIndex]); &#125; swap(arr, i, minIndex); &#125; &#125; 冒泡排序算法步骤 比较相邻的两个数，大的向后移。 最后的数是当前组中最大的了。从头开始步骤1的循环，直至排序结束。 Java实现123456789public static void BubbleSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j+1]) swap(arr, j, j+1); &#125; &#125; &#125; 插入排序算法步骤 将第一个元素看作有序序列，第二个至最后看作无序。 选择无序中第一个元素，一一与有序中元素比较，直到不符合条件就插入到当前对比的位置上。 有序+1，无序-1，循环。 Java实现12345678910public static void insertionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1]; j--) &#123; swap(arr, j, j - 1); &#125; &#125; &#125; 希尔排序希尔排序是改进的插入排序 算法步骤 选定一个间隔数，按照间隔数分组。 组内进行排序。 重新设置间隔数，重新再排序，循环。（间隔数至1时就是普通的插入排序） Java实现12345678910111213141516171819202122public static void shellSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; // 二分之一序列 for (int gap = arr.length &gt;&gt; 1; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; gap - 1; j -= gap) &#123; if (arr[j] &lt; arr[j-gap]) swap(arr, j, j-gap); &#125; &#125; &#125; // knuth序列 int h = 1; while (h &lt;= arr.length / 3) h = h * 3 + 1; for (int gap = h; gap &gt; 0; gap = (gap - 1) / 3) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; gap - 1; j -= gap) &#123; if (arr[j] &lt; arr[j-gap]) swap(arr, j, j-gap); &#125; &#125; &#125;","raw":null,"content":null,"categories":[],"tags":[]},{"title":"时间与空间复杂度","slug":"时间与空间复杂度","date":"2022-06-17T05:55:25.000Z","updated":"2022-06-17T05:56:01.913Z","comments":true,"path":"2022/06/17/时间与空间复杂度/","link":"","permalink":"http://example.com/2022/06/17/%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"时间复杂度时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。 大O「 大O符号表示法 」，即 T(n) &#x3D; O(f(n))。 其中 n 表示数据规模 ，O(f(n))表示运行算法所需要执行的指令数，和f(n)成正比。 常见的时间复杂度量级 常数阶O(1) 线性阶O(n) 平方阶O(n²) 对数阶O(logn) 线性对数阶O(nlogn) ![[Pasted image 20220114174550.png]] 递归算法的时间复杂度如果递归函数中，只进行一次递归调用，递归深度为depth；在每个递归的函数中，时间复杂度为T；则总体的时间复杂度为O(T * depth)。 归并排序 与 快速排序 都带有递归的思想，并且时间复杂度都是O(nlogn) ，但并不是有递归的函数就一定是 O(nlogn) 级别的。从递归中进行一次递归调用的复杂度分析、递归中进行多次递归调用的复杂度分析。 具体举例分析 最好、最坏情况时间复杂度最好、最坏情况时间复杂度指的是特殊情况下的时间复杂度。 当数组中第一个元素就是要找的 x 时，时间复杂度是 O(1)；而当最后一个元素才是 x 时，时间复杂度则是 O(n)。 最好情况时间复杂度就是在最理想情况下执行代码的时间复杂度，它的时间是最短的；最坏情况时间复杂度就是在最糟糕情况下执行代码的时间复杂度，它的时间是最长的。 平均情况时间复杂度最好、最坏时间复杂度反应的是极端条件下的复杂度，发生的概率不大，不能代表平均水平。那么为了更好的表示平均情况下的算法复杂度，就需要引入平均时间复杂度。 平均情况时间复杂度可用代码在所有可能情况下执行次数的加权平均值表示。 还是以 find 函数为例，从概率的角度看， x 在数组中每一个位置的可能性是相同的，为 1 &#x2F; n。那么，那么平均情况时间复杂度就可以用下面的方式计算： ((1 + 2 + … + n) &#x2F; n + n) &#x2F; 2 &#x3D; (3n + 1) &#x2F; 4 find 函数的平均时间复杂度为 O(n)。 123456789int find(int[] array, int n, int x) &#123; for ( int i = 0 ; i &lt; n; i++) &#123; if (array[i] == x) &#123; return i; break; &#125; &#125; return -1; &#125; 均摊复杂度分析一个相对比较耗时的操作，如果能保证它不会每次都被触发，那么这个相对比较耗时的操作，它所相应的时间是可以分摊到其它的操作中来的。 空间复杂度空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。 一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分： 固定部分，这部分空间的大小与输入&#x2F;输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。 一个算法所需的存储空间用f(n)表示。S(n)&#x3D;O(f(n))，其中n为问题的规模，S(n)表示空间复杂度。 空间复杂度可以理解为除了原始序列大小的内存，在算法过程中用到的额外的存储空间。 平衡二叉树如果二叉树的是以红黑树等平衡二叉树实现的，则 n 个节点的二叉排序树的高度为 log2n+1 ，其查找效率为O(Log2n)，近似于折半查找。 列表二叉树如果二叉树退变为列表了，则 n 个节点的高度或者说是长度变为了n，查找效率为O(n)，变成了顺序查找。 一般二叉树介于「列表二叉树」与「平衡二叉树」之间，查找性能也在O(Log2n)到O(n)之间。 时间与空间对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。 比如说，要判断某某年是不是闰年： 可以编写一个算法来计算，这也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。 还有另一个办法就是，事先建立一个有 5555 个元素的数组（年数比现实多就行），然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是1，如果不是值为0。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时，我们的运算是最小化了，但是硬盘上或者内存中需要存储这 5555 个 0 和 1 。这就是典型的使用空间换时间的概念。 当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。 另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-06-14T06:34:04.851Z","updated":"2022-06-14T06:34:04.855Z","comments":true,"path":"2022/06/14/hello-world/","link":"","permalink":"http://example.com/2022/06/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[],"tags":[]}]}